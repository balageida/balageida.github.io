<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一个游戏程序员的blog">
<meta name="keywords" content="game;program;render;PBR;">
<meta property="og:type" content="website">
<meta property="og:title" content="Stoner">
<meta property="og:url" content="http://noleafnolife.com/page/2/index.html">
<meta property="og:site_name" content="Stoner">
<meta property="og:description" content="一个游戏程序员的blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stoner">
<meta name="twitter:description" content="一个游戏程序员的blog">






  <link rel="canonical" href="http://noleafnolife.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Stoner</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Stoner</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">做此刻最想做的事</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://noleafnolife.com/2019/04/05/sdk/graphics/vulkan/6.RenderPassesAndFramebuffers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nolife">
      <meta itemprop="description" content="一个游戏程序员的blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stoner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/05/sdk/graphics/vulkan/6.RenderPassesAndFramebuffers/" class="post-title-link" itemprop="url">Render Passes and Framebuffers</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-05 21:16:00 / Modified: 21:19:56" itemprop="dateCreated datePublished" datetime="2019-04-05T21:16:00+08:00">2019-04-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/" itemprop="url" rel="index"><span itemprop="name">sdk</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/" itemprop="url" rel="index"><span itemprop="name">graphics</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/vulkan/" itemprop="url" rel="index"><span itemprop="name">vulkan</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="Render-Passes-and-Framebuffers"><a href="#Render-Passes-and-Framebuffers" class="headerlink" title="Render Passes and Framebuffers"></a>Render Passes and Framebuffers</h1><p>[TOC]</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>内容</p>
<blockquote>
<ul>
<li>Specifying attachment descriptions</li>
<li>Specifying subpass descriptions</li>
<li>Specifying dependencies between subpasses</li>
<li>Creating a render pass</li>
<li>Creating a framebuffer</li>
<li>Preparing a render pass for geometry rendering and postprocess subpasses</li>
<li>Preparing a render pass and a framebuffer with color and depth attachments</li>
<li>Beginning a render pass</li>
<li>Progressing to the next subpass</li>
<li>Ending a render pass</li>
<li>Destroying a framebuffer</li>
<li>Destroying a render pass</li>
</ul>
</blockquote>
<p>dc在render passes中组织.一个render pass是subpasses的集合.subpass描述images 资源(color,depth/stencil,input attachment)如何被使用:layouts是什么,在subpasses间layouts如何变换,何时向attachments渲染或合适从里面读数据,renderpass介绍后它们的内容是否有用,或它们的suage是否只被限制在一个render pass里.</p>
<p>存储在渲染过程中的上述数据只是一个general description或metadata.在rendering process中真实的resources为framebuffers.通过他们,定义了rendering atatchments的image views.</p>
<p>我们需要提前准备这些信息,在我们能issue(record)rendering commands前.有了这些信息,驱动能高效控制drawing process,限制rendering的memory 数量,或者给某些attachments使用非常快的cache,提高更多性能.</p>
<p>接下来讨论如何组织renderpasses和subpasses的drawing操作.以及如何准备RT,创建framebuffers–用作attachments的image views.</p>
<h2 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a>descriptor</h2><h3 id="specifying-attachments-descriptions"><a href="#specifying-attachments-descriptions" class="headerlink" title="specifying attachments descriptions"></a>specifying attachments descriptions</h3><p>一个render pass是一组资源的集合(images)叫做attachments,用于rendering操作.分为color,depth/stencil,input,或者attachments.在创建render pass前,需要描述所有的attachmetns.<br>创建一组attachment descriptions.这个数组的indices之后也用于subpass descriptions.类似,创建一个framebuffer和指明每个attachment使用哪个image resources,定义了一个列表其每个元素对应于attachment descriptions数组.</p>
<p>通常绘制一个几何体,至少需要一个color attachment.可能还需要depth attachment(如果开启depth test).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkAttachmentDescription&gt; attachments_descriptions = </span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">        VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">        VK_ATTACHMENT_LOAD_OP_CLEAR,</span><br><span class="line">        VK_ATTACHMENT_STORE_OP_STORE,</span><br><span class="line">        VK_ATTACHMENT_LOAD_OP_DONT_CARE,</span><br><span class="line">        VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">        VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_FORMAT_D16_UNORM,</span><br><span class="line">        VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">        VK_ATTACHMENT_LOAD_OP_CLEAR,</span><br><span class="line">        VK_ATTACHMENT_STORE_OP_STORE,</span><br><span class="line">        VK_ATTACHMENT_LOAD_OP_DONT_CARE,</span><br><span class="line">        VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">        VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在之前的例子,指明了两个attachments:一个R8G8B8A8_UNORM和一个D16_UNORM格式的.二者在render pass开始都需要clear.(类似glClear).当render pass完成时,我们想保持第一个attachment的内容,单不想第二个attachment的内容.二者都指明一个UNDEFINED intial layout–总能用于一个initial/old layout–意味着当memory barrier set up 时我们不需要images内容.</p>
<p>final layout的内容依赖于在render pass后我们如何使用image.如果我们直接向一个swapchain image渲染且想显示到屏幕上,我们需要PRESENT_SRC layout.对于depth attachment,如果render pass之后不想用depth component(通常为true),需要需要再render pass的最后的subpass set the same layout value as specified.</p>
<p>也有可能一个render pass不用任何attachments.此时不需要指明attachment descriptions但这种情况很少.</p>
<h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><h3 id="Specifying-subpass-descriptions"><a href="#Specifying-subpass-descriptions" class="headerlink" title="Specifying subpass descriptions"></a>Specifying subpass descriptions</h3><p>再render pass中的操作被组织再subpasses中.每个subpass表示rendering commands(a subset of render pass’s attachments are  used)的一个stage或一个phase.</p>
<p>一个render pass总需要至少一个subpass—当开始一个render pass时自动允许的.对于每个subpass,需要准备一个description.</p>
<p>为了减少参数,定义一个自定义结构体.它是vulkan头文件中定义的vksubpassDescription结构的简化版本.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubpassParameters</span> &#123;</span></span><br><span class="line">    VkPipelineBindPoint PipelineType;<span class="comment">//定义了pipeline type(graphic,compute.)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkAttachmentReference&gt; InputAttachments;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkAttachmentReference&gt; ColorAttachments;</span><br><span class="line">    <span class="comment">//指明哪些color attachments需要在subpass结束时resolved(从多采样图像更改为非多采样/单采样图像)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkAttachmentReference&gt; ResolveAttachments;</span><br><span class="line">    <span class="comment">//如果用了,指明哪个attachment用于depth and/or stencil attachment.</span></span><br><span class="line">    VkAttachmentReference <span class="keyword">const</span> * DepthStencilAttachment;</span><br><span class="line">    <span class="comment">//一组不用于subpass但其内容在整个subpass中需要preserved</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; PreserveAttachments;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再总结一下.</p>
<p>vulkan的render pass至少要有一个subpass,subpass参数定义在一组VkSubpassDescription中,每个这样的元素描述了attachments在关联的subpass中如何使用的.他们是分开的input,color,resolve,preserved attachments和单个entry for depth/stencil attachments的列表.所有成员都可能为空,在这种情况下,子类中不使用相应类型的attachment.</p>
<p>刚刚描述的列表中的每个条目都是再attachment descriptions中为render pass指明的attachments的列表的引用.此外,每个条目都指定了一个布局,其中图像应该在子类期间出现.驱动程序自动执行到指定布局的转换.</p>
<p>下面是使用子类参数类型的自定义结构指定子类定义的代码示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">subpass_descriptions.clear();</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; subpass_description : subpass_parameters ) &#123;</span><br><span class="line">    subpass_descriptions.push_back( &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        subpass_description.PipelineType,</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(subpass_description.InputAttachments.size()),</span><br><span class="line">        subpass_description.InputAttachments.data(),</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(subpass_description.ColorAttachments.size()),</span><br><span class="line">        subpass_description.ColorAttachments.data(),</span><br><span class="line">        subpass_description.ResolveAttachments.data(),</span><br><span class="line">        subpass_description.DepthStencilAttachment,</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(subpass_description.PreserveAttachments.size()),</span><br><span class="line">        subpass_description.PreserveAttachments.data()</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个使用一个color attachment:a depth/stencil attachment的一个subpass的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VkAttachmentReference depth_stencil_attachment = &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="comment">//index</span></span><br><span class="line">    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SubpassParameters&gt; subpass_parameters = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">        VK_PIPELINE_BIND_POINT_GRAPHICS,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">0</span>,<span class="comment">//index</span></span><br><span class="line">                VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &amp;depth_stencil_attachment,</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="specifying-dependencies-between-subpasses"><a href="#specifying-dependencies-between-subpasses" class="headerlink" title="specifying dependencies between subpasses"></a>specifying dependencies between subpasses</h3><p>当subpass有依赖关系时需要指明subpass dependencies.</p>
<p>定义subpass dependencies与memory barrier相似.</p>
<p>指明subpass之间(或subpass和render pass之后/之前的commands之间)与设置image memory barrier相似.当位于某个subpass的commands以来另一个subpass时需要这样做.不需要设置layout transitions的dependencies.它们时根据render pass attachment和subpass descriptions自动进行的,但如果两个subpass中attachment都是只读的,就不需要指明dependency了.</p>
<p>在render pass建立image memory barriers也需要subpass dependencies.但不能”self-dependency”(source和dest的index相同).但如果给已有subpass定义了一个这样的dependency,我们能record一个memory barrier.其他情况,source subpass index必须比target subpass index小(除了VK_SUBPASS_EXTERNAL)</p>
<p>下例,准备了两个subpass之间的dependency–第一个绘制geometry到color和depth attachments,第二个使用color data做后处理.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkSubpassDependency&gt; subpass_dependencies = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,<span class="comment">//第一个subpass</span></span><br><span class="line">        <span class="number">1</span>,<span class="comment">//第二个subpass</span></span><br><span class="line">        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,<span class="comment">//stage for 0</span></span><br><span class="line">        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,</span><br><span class="line">        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,<span class="comment">//access mask for 0</span></span><br><span class="line">        VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,<span class="comment">//access mask for 1</span></span><br><span class="line">        VK_DEPENDENCY_BY_REGION_BIT;<span class="comment">//第一个subpass在一个坐标写一个值,第二个subpass在相同坐标读取到相同的值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>VK_DEPENDENCY_BY_REGION_BIT我们这样做时,我们不应该假设区域大于单个像素,因为在不同的硬件平台上,区域的大小可能不同.</p>
<h3 id="creating-a-render-pass"><a href="#creating-a-render-pass" class="headerlink" title="creating a render pass"></a>creating a render pass</h3><p>后处理等操作需要在subpasses里对这些操作排序.指明所有需要的attachments的descriptions,所有组织操作的 subpasses,还有这些操作间必要的dependencies.这些数据准备好后,能创建render pass了.</p>
<p>vkCreateRenderPass</p>
<p><img src="media/renderpass1.png" alt></p>
<p>render pass创建最重要的部分是准备数据.descriptions.所有用到的attachments和subpasses和subpasses间的dependencies的descriptions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpecifyAttachmentsDescriptions( attachments_descriptions );</span><br><span class="line">std::vector&lt;VkSubpassDescription&gt; subpass_descriptions;</span><br><span class="line">SpecifySubpassDescriptions( subpass_parameters, subpass_descriptions );</span><br><span class="line">SpecifyDependenciesBetweenSubpasses( subpass_dependencies );</span><br></pre></td></tr></table></figure>
<p>在创建render pass时作为参数使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">VkRenderPassCreateInfo render_pass_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(attachments_descriptions.size()),</span><br><span class="line">    attachments_descriptions.data(),</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(subpass_descriptions.size()),</span><br><span class="line">    subpass_descriptions.data(),</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(subpass_dependencies.size()),</span><br><span class="line">    subpass_dependencies.data()</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreateRenderPass( logical_device,</span><br><span class="line">&amp;render_pass_create_info, <span class="literal">nullptr</span>, &amp;render_pass );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create a render pass."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>为了让render pass正常工作,有关用于所有已定义attachments的特定资源的此类信息存储在framebuffers中。</p>
<h3 id="creating-a-framebuffer"><a href="#creating-a-framebuffer" class="headerlink" title="creating a framebuffer"></a>creating a framebuffer</h3><p>framebuffers和render passes一起使用.它们指明了render pass里与之关联的attachments使用什么image resources.也定义了可渲染区域的尺寸.</p>
<p>framebuffer总是和render passes一起创建,它们定义了用于渲染过程中指定的attachments的特定image subresources，因此这两种对象类型应相互对应.</p>
<p><img src="media/framebuffer1.png" alt></p>
<p>当创建frame buffer,提供一个render pass object能使用这个fb.但也不限于用这个特定的render pass使用它.所有可以兼容的render passes都可以用它.</p>
<p>什么是兼容的(compatible)render passes?第一,相同数量的subpasses.每个subpass有compatible的input,color,resolve,depth/stencil attachments.但是,需要记住确保特定区域外的pixels/fragments是未定义的.为此需要在创建pipeline时或者设置对应动态状态时指明一些参数(viewport和scissor test)(相关间:preparing view port and scissor test state c8,graphics and compute piplines ,setting a dynamic viewport and scissors state c9,command recording and drawing).</p>
<p>当开始render pass,使用framebuffer时,需要确保images在framebuffer中指明的subresources不用于其他目的.换句话说,如果使用了image作为framebuffer attachment,就不能降至用于其他render pass.</p>
<p>创建framebuffer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">VkFramebufferCreateInfo framebuffer_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    render_pass,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(attachments.size()),</span><br><span class="line">    attachments.data(),</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    layers</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreateFramebuffer( logical_device,</span><br><span class="line">    &amp;framebuffer_create_info, <span class="literal">nullptr</span>, &amp;framebuffer );</span><br><span class="line">    <span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create a framebuffer."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="preparing-a-render-pass-for-geometry-rendering-and-postprocess-subpasses"><a href="#preparing-a-render-pass-for-geometry-rendering-and-postprocess-subpasses" class="headerlink" title="preparing a render pass for geometry rendering and postprocess subpasses"></a>preparing a render pass for geometry rendering and postprocess subpasses</h3><p>介绍两个subpasses的例子.第一个是有两个attachments–color和depth.第二个从第一个color attachment读取数据并render到另一个color attachment(swapchain image,能显示到屏幕上).</p>
<p>3个attachments</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkAttachmentDescription&gt; attachments_descriptions = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">    VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_CLEAR,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_DONT_CARE,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">    VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    VK_FORMAT_D16_UNORM,</span><br><span class="line">    VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_CLEAR,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_DONT_CARE,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">    VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">    VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_CLEAR,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_STORE,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_DONT_CARE,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">    VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个是第一个subpass的color attachment和第二个subpass读取数据的.第二个attachment是depth数据;第三个是第二个subpass的color attachment.在render pass之后不需要第一个和第二个attachments了,需要给它们的store operations指明VK_ATTACHMENT_STORE_OP_DONT_CARE.render pass一开始也不需要它们的内容,所以知名一个未定义的layout.也clear三个attachments.</p>
<p>定义2个subpasses:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">VkAttachmentReference depth_stencil_attachment = &#123;</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SubpassParameters&gt; subpass_parameters = &#123;</span><br><span class="line">    <span class="comment">// #0 subpass</span></span><br><span class="line">    &#123;</span><br><span class="line">        VK_PIPELINE_BIND_POINT_GRAPHICS,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &amp;depth_stencil_attachment,</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// #1 subpass</span></span><br><span class="line">        &#123;</span><br><span class="line">        VK_PIPELINE_BIND_POINT_GRAPHICS,</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后定义两个subpasses关于第一个attachment的dependency,一个时color attachment,另一个是input attachment.然后创建render pass</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkSubpassDependency&gt; subpass_dependencies = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,</span><br><span class="line">        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,</span><br><span class="line">        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,</span><br><span class="line">        VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,</span><br><span class="line">        VK_DEPENDENCY_BY_REGION_BIT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>( !CreateRenderPass( logical_device, attachments_descriptions,</span><br><span class="line">    subpass_parameters, subpass_dependencies, render_pass ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="reparing-a-rener-pass-and-a-framebuffer-with-color-and-depth-attachments"><a href="#reparing-a-rener-pass-and-a-framebuffer-with-color-and-depth-attachments" class="headerlink" title="reparing a rener pass and a framebuffer with color and depth attachments"></a>reparing a rener pass and a framebuffer with color and depth attachments</h3><p>3D场景渲染除了需要color attachment还需要给depth testing准备depth attachment.</p>
<p>本节介绍给color和depth数据创建images,创建只有单个subpass(向color和dpeth attachments渲染)的render pass.创建在render pass attachments中使用这两个images的framebuffer.</p>
<p>1.想在render pass里作为RT，usages为COLOR_ATTACHMENT / DEPTH_STENCIL_ATTACHMENT</p>
<p>2.向在render pass之后作为sample 用的textures,usage:SAMPLED</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !Create2DImageAndView( physical_device, logical_device,</span><br><span class="line">VK_FORMAT_R8G8B8A8_UNORM, &#123; width, height &#125;, <span class="number">1</span>, <span class="number">1</span>, VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,</span><br><span class="line">VK_IMAGE_ASPECT_COLOR_BIT, color_image, color_image_memory_object,</span><br><span class="line">color_image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !Create2DImageAndView( physical_device, logical_device,</span><br><span class="line">VK_FORMAT_D16_UNORM, <span class="comment">//format</span></span><br><span class="line">&#123; width, height &#125;, <span class="number">1</span>, <span class="number">1</span>, VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,<span class="comment">//usage</span></span><br><span class="line">VK_IMAGE_ASPECT_DEPTH_BIT, depth_image, depth_image_memory_object,</span><br><span class="line">depth_image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将2个attachment指给render pass,他们在render pass开始都clear,render pass之后内容都保持</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkAttachmentDescription&gt; attachments_descriptions = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">    VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_CLEAR,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_STORE,</span><br><span class="line">    VK_ATTACHMENT_LOAD_OP_DONT_CARE,</span><br><span class="line">    VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">    VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_FORMAT_D16_UNORM,</span><br><span class="line">        VK_SAMPLE_COUNT_1_BIT,</span><br><span class="line">        VK_ATTACHMENT_LOAD_OP_CLEAR,</span><br><span class="line">        VK_ATTACHMENT_STORE_OP_STORE,</span><br><span class="line">        VK_ATTACHMENT_LOAD_OP_DONT_CARE,</span><br><span class="line">        VK_ATTACHMENT_STORE_OP_DONT_CARE,</span><br><span class="line">        VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">        VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下一步是定义一个subpass,将第一个attachment作为color,第二个作为depth/stencil</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VkAttachmentReference depth_stencil_attachment = &#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SubpassParameters&gt; subpass_parameters = &#123;</span><br><span class="line">&#123;</span><br><span class="line">    VK_PIPELINE_BIND_POINT_GRAPHICS,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &amp;depth_stencil_attachment,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后定义subpass和render pass后执行的commands的dependency.</p>
<p>这有必要,因为不想在render pass里正在写数据时其他commands就开始才能够images里读取数据.也创建renderpass和framebufer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkSubpassDependency&gt; subpass_dependencies = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_SUBPASS_EXTERNAL,</span><br><span class="line">        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,</span><br><span class="line">        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,</span><br><span class="line">        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,</span><br><span class="line">        VK_ACCESS_SHADER_READ_BIT,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>( !CreateRenderPass( logical_device, attachments_descriptions,</span><br><span class="line">subpasses_parameters, subpasses_dependencies, render_pass ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !CreateFramebuffer( logical_device, render_pass, </span><br><span class="line">&#123; color_image_view,depth_image_view &#125;,</span><br><span class="line">width, height, <span class="number">1</span>, framebuffer ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="beginning-a-render-pass"><a href="#beginning-a-render-pass" class="headerlink" title="beginning a render pass"></a>beginning a render pass</h3><p>创建好render pass和frame buffer且准备开始recording commands绘制geometry,需要一个开始render pass的record操作.这个操作同时也自动开始它的第一个subbpass.在这完成前VkRenderPassBeginInfo:准备就绪</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkRenderPassBeginInfo render_pass_begin_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    render_pass,</span><br><span class="line">    framebuffer,</span><br><span class="line">    render_area,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(clear_values.size()),</span><br><span class="line">    clear_values.data()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clearing values的数组至少要和attachments对应的元素个数一样.只需要给需要clear的提供值.可以提供nullptr.</p>
<p>当开始render pass,需要提供render area的dimentsions.可以和frame buffer的dimension一样也可以更小.我们要确保渲染将局限于指定的区域,否则超出此范围的像素可能会变得未定义.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vkCmdBeginRenderPass( command_buffer, &amp;render_pass_begin_info,</span><br><span class="line">subpass_contents );</span><br></pre></td></tr></table></figure>
<h3 id="progressing-to-the-next-subpass"><a href="#progressing-to-the-next-subpass" class="headerlink" title="progressing to the next subpass"></a>progressing to the next subpass</h3><p>一个render pass里record的commands分散在subpasses里.当给定subpass里的commands集已经recorded且想给另一个subpass record commands,需要switch(or progress)到下一个subpass.</p>
<p>同一个render pass.</p>
<p>在此操作过程中,将执行适当的layout transitions,并引入memory和执行依赖(与meemory arriers里类似).都是驱动自动进行的,因此如果需要,新的subpass能按照创建render pass指明的方式使用attachemnts.移到下一个subpass也performs multisample resolve operations  on specified color attachments.</p>
<p>subpass里的commands可以直接在command buffer里record,也可以在第二个command bufer里间接执行.(Commands in the subpass can be recorded directly, by inlining them in the command buffer, or indirectly by executing a secondary command buffer.)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkCmdNextSubpass( command_buffer, subpass_contents );</span><br></pre></td></tr></table></figure>
<h3 id="ending-a-render-pass"><a href="#ending-a-render-pass" class="headerlink" title="ending a render pass"></a>ending a render pass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkCmdEndRenderPass( command_buffer );</span><br></pre></td></tr></table></figure>
<p>在一个command bufffer里record这个函数会执行多个操作.引入执行和内存依赖性（如内存屏障中的那些）,并执行图像布局转换——将图像从为最后一个子类指定的布局转换为最终布局的值（请参阅指定附件描述方法）.Also multisample resolving is performed on color attachments for which resolving was specified in the last subpass. dditionally, for attachments whose contents should be preserved after the render pass,  attachment data may be transferred from the cache to the image’s memory.</p>
<h2 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h2><h3 id="destroy-a-framebuffer"><a href="#destroy-a-framebuffer" class="headerlink" title="destroy a framebuffer"></a>destroy a framebuffer</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != framebuffer ) &#123;</span><br><span class="line">	vkDestroyFramebuffer( logical_device, framebuffer, <span class="literal">nullptr</span> );</span><br><span class="line">	framebuffer = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在销毁它前需要确保commands不会继续执行</p>
<h3 id="destroying-a-render-pass"><a href="#destroying-a-render-pass" class="headerlink" title="destroying a render pass"></a>destroying a render pass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != render_pass ) &#123;</span><br><span class="line">	vkDestroyRenderPass( logical_device, render_pass, <span class="literal">nullptr</span> );</span><br><span class="line">	render_pass = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://noleafnolife.com/2019/04/05/sdk/graphics/vulkan/2.ImagePresentation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nolife">
      <meta itemprop="description" content="一个游戏程序员的blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stoner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/05/sdk/graphics/vulkan/2.ImagePresentation/" class="post-title-link" itemprop="url">Image Presentation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-05 21:16:00 / Modified: 21:19:13" itemprop="dateCreated datePublished" datetime="2019-04-05T21:16:00+08:00">2019-04-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/" itemprop="url" rel="index"><span itemprop="name">sdk</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/" itemprop="url" rel="index"><span itemprop="name">graphics</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/vulkan/" itemprop="url" rel="index"><span itemprop="name">vulkan</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>[TOC]</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><blockquote>
<ul>
<li>创建一个激活WSI扩展的Vulkan Instance</li>
<li>创建一个presentation surface</li>
<li>选择一个支持已给surface的queue family</li>
<li>创建一个有WSI扩展的logical device</li>
<li>选择一个期望的presentation mode</li>
<li>获得presentation surface的策略</li>
<li>设置swapchain images的大小</li>
<li>选择一个期望的swapchain iamges的方案</li>
<li>选择swapchain images交换方法</li>
<li>选择swapchain images格式</li>
<li>创建swapchain</li>
<li>获得swapchain images的handles</li>
<li>创建一个R8G8B8A8格式和mailbox显示模式的swapchain</li>
<li>请求一个swapchain image</li>
<li>销毁swapchain</li>
<li>销毁presentation surface</li>
</ul>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Vulkan API本身由于跨平台考虑，本身不带有显示生成的图像到窗口的接口,但一组扩展接口(Windowing System Integration(WSI))支持了这种操作.每个支持Vulkan的操作系统有它自己的扩展.</p>
<p>最重要的扩展是允许我们创建一个swapchain.swapchain是一组images，能展示(显示)给用户.</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="instance-with-WSI-extensions"><a href="#instance-with-WSI-extensions" class="headerlink" title="instance with WSI extensions"></a>instance with WSI extensions</h3><p>WSI extension分为Instance 和device levels.</p>
<p>第一步是创建激活了对应扩展运行创建presentation surface的Vulkan Instance</p>
<p>Instance-level extensions负责管理、创建、销毁一个presentation surface.它是一个软件的窗口的(跨平台的)representation.通过它,我们能检查是否能绘制窗口(显示图片、一个queue family的额外属性)，能知道它的参数，它支持什么(如果向垂直同步激活或关闭).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">desired_extensions.emplace_back( VK_KHR_SURFACE_EXTENSION_NAME );<span class="comment">//所有os都支持,用于管理、删除khr</span></span><br><span class="line">desired_extensions.emplace_back(</span><br><span class="line">#ifdef VK_USE_PLATFORM_WIN32_KHR </span><br><span class="line">VK_KHR_WIN32_SURFACE_EXTENSION_NAME <span class="comment">//windows</span></span><br><span class="line">#elif defined VK_USE_PLATFORM_XCB_KHR</span><br><span class="line">VK_KHR_XCB_SURFACE_EXTENSION_NAME <span class="comment">//linux xcb</span></span><br><span class="line">#elif defined VK_USE_PLATFORM_XLIB_KHR</span><br><span class="line">VK_KHR_XLIB_SURFACE_EXTENSION_NAME <span class="comment">//linux xlib</span></span><br><span class="line">#endif</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> CreateVulkanInstance( desired_extensions, application_name, instance</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="创建presentation-surface"><a href="#创建presentation-surface" class="headerlink" title="创建presentation surface"></a>创建presentation surface</h3><p>presentation显示软件的窗口,允许我们获取窗口的参数(比如尺寸,支持的颜色格式,请求的images数量,或者显示模式).</p>
<p>前提:windows已经创建</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WindowParameters</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VK_USE_PLATFORM_WIN32_KHR</span></span><br><span class="line">HINSTANCE HInstance;</span><br><span class="line">HWND HWnd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined VK_USE_PLATFORM_XLIB_KHR</span></span><br><span class="line">Display * Dpy;</span><br><span class="line">Window Window;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined VK_USE_PLATFORM_XCB_KHR</span></span><br><span class="line"><span class="keyword">xcb_connection_t</span> * Connection;</span><br><span class="line"><span class="keyword">xcb_window_t</span> Window;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VK_USE_PLATFORM_WIN32_KHR</span></span><br><span class="line">VkWin32SurfaceCreateInfoKHR surface_create_info = &#123;</span><br><span class="line">VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,</span><br><span class="line"><span class="literal">nullptr</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">window_parameters.HInstance,</span><br><span class="line">window_parameters.HWnd</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreateWin32SurfaceKHR( instance, &amp;surface_create_info,</span><br><span class="line"><span class="literal">nullptr</span>, &amp;presentation_surface );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined VK_USE_PLATFORM_XLIB_KHR</span></span><br><span class="line">VkXlibSurfaceCreateInfoKHR surface_create_info = &#123;</span><br><span class="line">VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,</span><br><span class="line"><span class="literal">nullptr</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">window_parameters.Dpy,</span><br><span class="line">window_parameters.Window</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreateXlibSurfaceKHR( instance, &amp;surface_create_info,</span><br><span class="line"><span class="literal">nullptr</span>, &amp;presentation_surface );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined VK_USE_PLATFORM_XCB_KHR</span></span><br><span class="line">VkXcbSurfaceCreateInfoKHR surface_create_info = &#123;</span><br><span class="line">VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,</span><br><span class="line"><span class="literal">nullptr</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">window_parameters.Connection,</span><br><span class="line">window_parameters.Window</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreateXcbSurfaceKHR( instance, &amp;surface_create_info,</span><br><span class="line"><span class="literal">nullptr</span>, &amp;presentation_surface );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="选择支持给定表面显示的queue-family"><a href="#选择支持给定表面显示的queue-family" class="headerlink" title="选择支持给定表面显示的queue family"></a>选择支持给定表面显示的queue family</h3><p>显示图像是通过提交特色的command到device的queue实现的.所以要求对应的queue支持.</p>
<p>目前queue family可能支持的特性有:Image presentation,graphics,compute,transfer,sparse operations.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">uint32_t</span> index = <span class="number">0</span>; index &lt;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(queue_families.size()); ++index ) &#123;</span><br><span class="line">VkBool32 presentation_supported = VK_FALSE;</span><br><span class="line">VkResult result = vkGetPhysicalDeviceSurfaceSupportKHR( physical_device,</span><br><span class="line">index, presentation_surface, &amp;presentation_supported );</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS == result) &amp;&amp;</span><br><span class="line">(VK_TRUE == presentation_supported) ) &#123;</span><br><span class="line">queue_family_index = index;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>通过vkGetPhysicalDeviceSurfaceSupportKHR接口进行检查</p>
<h3 id="logical-device-with-WSI-extensions"><a href="#logical-device-with-WSI-extensions" class="headerlink" title="logical device with WSI extensions"></a>logical device with WSI extensions</h3><p>一个device-level WSI扩展允许创建一个swapchain.这是一组被presentation engine管理的images.</p>
<p>VK_KHR_swapchain</p>
<p>一个swapchain,列举了image format,images 数量(双缓存或三缓存),presentation mode(v-sync 激活/关闭).伴随着swapchain创建的images被presentation engine所有和管理.需要使用时,需要请求,绘制,归还到presentation engine.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desired_extensions.emplace_back( VK_KHR_SWAPCHAIN_EXTENSION_NAME );</span><br><span class="line"><span class="keyword">return</span> CreateLogicalDevice( physical_device, queue_infos,</span><br><span class="line">desired_extensions, desired_features, logical_device );</span><br></pre></td></tr></table></figure>
<h3 id="选择期望的presentation-mode"><a href="#选择期望的presentation-mode" class="headerlink" title="选择期望的presentation mode"></a>选择期望的presentation mode</h3><p>vulkan的swapchain最重要的特性是将图像显示倒屏幕,也是swap’chain的设计目的.</p>
<p>有四种模式.</p>
<p>最简单的是IMMEDIATE模式.会有屏幕撕裂现象</p>
<p><img src="media/presentatinsurface1.png" alt></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>Vulkan API实现都必须支持的是FIFO模式.   </p>
<p>FIFO RELAXED是FIFO的简单变体.不同之处是RELAXED模式,只有当图像显示足够快,比刷新率还快时才会在空白期显示图像到屏幕上.如果应用程序显示了一个图像,并且从上次显示到现在所花费的时间大于两个空白周期之间的刷新时间(FIFO queue为空),图像立即显示.因此如果足够快,这里不会有撕裂,但如果绘制得比屏幕刷新慢，会出现撕裂.这个mode与OpenGL的EXT_swap_control_tear扩展类似.</p>
<p><img src="media/swapchainFIFO.png" alt></p>
<p>最后一种为mailbox模式.它可以被看做是三重缓冲.有一个只包含一个元素的队列.一个image在这个队列里等待在空白期同步显示(v-sync激活)显示.但当app显示一张image时,新的一张新的image会替换掉队列里的.所以presentation engine总是显示最新的,没有屏幕撕裂.</p>
<p><img src="media/swapchainmailbox.png" alt></p>
<p>检查可用modes.vkGetPhysicalDeviceSurfacePresentModesKHR.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> present_modes_count = <span class="number">0</span>;</span><br><span class="line">VkResult result = VK_SUCCESS;</span><br><span class="line">result = vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device,</span><br><span class="line">presentation_surface, &amp;present_modes_count, <span class="literal">nullptr</span> );</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS != result) ||</span><br><span class="line">(<span class="number">0</span> == present_modes_count) ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not get the number of supported present modes."</span> &lt;&lt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkPresentModeKHR&gt; present_modes( present_modes_count );</span><br><span class="line">result = vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device,</span><br><span class="line">presentation_surface, &amp;present_modes_count, &amp;present_modes[<span class="number">0</span>] );</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS != result) ||</span><br><span class="line">(<span class="number">0</span> == present_modes_count) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not enumerate present modes."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得了支持的所有modes后,选择一个期望的.如果不支持则选择默认的FIFO(总被支持).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; current_present_mode : present_modes ) &#123;</span><br><span class="line"><span class="keyword">if</span>( current_present_mode == desired_present_mode ) &#123;</span><br><span class="line">present_mode = desired_present_mode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Desired present mode is not supported. Selecting default FIFO</span></span><br><span class="line"><span class="string">mode."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; current_present_mode : present_modes ) &#123;</span><br><span class="line"><span class="keyword">if</span>( current_present_mode == VK_PRESENT_MODE_FIFO_KHR ) &#123;</span><br><span class="line">present_mode = VK_PRESENT_MODE_FIFO_KHR;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获得一个presentation-surface的功能"><a href="#获得一个presentation-surface的功能" class="headerlink" title="获得一个presentation surface的功能"></a>获得一个presentation surface的功能</h3><p>当创建一个swapchain时,不能选择我们想要的值而是指定参数.必须提供被presentation surface支持的限制范围内的值.因此为了正确创建swapchain,我们需要获得surface的功能.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(</span><br><span class="line">physical_device, presentation_surface, &amp;surface_capabilities );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not get the capabilities of a presentation surface."</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>VkSurfaceCapabilitiesKHR</p>
<blockquote>
<ul>
<li>swapchain images的最小和最大允许数量</li>
<li>表面的最小、最大、当前范围</li>
<li>支持图像转换(在显示前应用),其实就是是否进行sRGB转换,可能在不同平台支持特性不同,也就是要注意是否要自己进行转换</li>
<li>image layers最大数量</li>
<li>支持的usages</li>
<li>支持曲面的alpha值(图像的alpha组件该如何影响应用程序的窗口桌面合成)的支持的组件列表</li>
</ul>
</blockquote>
<p>内容包括</p>
<blockquote>
<ul>
<li>创建一个presentation surface</li>
<li>select swapchain images的个数</li>
<li>choose swapchain images的尺寸</li>
<li>select swapchain chains的期望的usage</li>
<li>select swapchain images的transformation</li>
<li>select swapchain images的format</li>
<li>创建一个swapchain</li>
</ul>
</blockquote>
<h3 id="select-swapchain-iamges的数量"><a href="#select-swapchain-iamges的数量" class="headerlink" title="select swapchain iamges的数量"></a>select swapchain iamges的数量</h3><p>当app想向swapchain image里渲染时,必须向prsentation engine请求它.app可以请求多张images,不限制一次请求一张.但可用的images(presentation engine 没在使用的)数量与presentation mode,app当前状态(渲染、显示的历史),images数量(创建swapchain时指定(最小))有关.</p>
<p>相关结构</p>
<p>VkSurfaceCapabilitiesKHR</p>
<blockquote>
<p>.minImageCount,一般将minImageCount.+1作为请求数量</p>
<p>.maxImageCount,如果&gt;0则对能创建的images最大数量有限制,就需要修正请求的images 数量了</p>
</blockquote>
<p>伴随swapchain创经济的images主要用作显示目的.但它们也表示引擎正常工作.知道它被替换,app不能使用它(image).images立即替换现实中的image或者在队列里等待替换它(v-sync)–基于选择的mode.app只能请求处于unused 状态的image.(可以请求所有unused状态的images).但同时,需要present至少一张image,否则请求操作会死锁.</p>
<p>未使用的映像的数量主要取决于表示模式和使用swapchain创建的images的总数.因此,我们想要创建的图像的数量应该根据我们想要实现的呈现场景(应用程序想同时拥有多少图像)和所选的当前模式来选择.</p>
<p>请求最小数量的Images:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number_of_images = surface_capabilities.minImageCount + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>( (surface_capabilities.maxImageCount &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">(number_of_images &gt; surface_capabilities.maxImageCount) ) &#123;</span><br><span class="line">number_of_images = surface_capabilities.maxImageCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>Vulkan API实现都必须支持的是FIFO模式.</p>
<p>选择需求需要的images数量</p>
<h3 id="choose-swapchain-images-size"><a href="#choose-swapchain-images-size" class="headerlink" title="choose swapchain images size *"></a>choose swapchain images size *</h3><p>通常要适合window大小,支持的dimensions再presentation surface的属性里有.但有的操作系统,iamges的size决定了最终window的大小.</p>
<p>同时也要记住去检查swapchain images的适合的dimensions.</p>
<p>相关结构</p>
<p>VkSurfaceCapabilitiesKHR</p>
<p>VkExtent2D</p>
<p>检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果surface_capabilities.currentExtent.width==-1</span></span><br><span class="line"><span class="comment">//则image的size决定windows的size</span></span><br><span class="line"><span class="keyword">if</span>( <span class="number">0xFFFFFFFF</span> == surface_capabilities.currentExtent.width ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这种情况就根据surface 属性调节image size</span></span><br><span class="line">    size_of_images = &#123; <span class="number">640</span>, <span class="number">480</span> &#125;;</span><br><span class="line">    <span class="comment">//范围检查</span></span><br><span class="line">    <span class="keyword">if</span>( size_of_images.width &lt; surface_capabilities.minImageExtent.width ) </span><br><span class="line">    &#123;</span><br><span class="line">    	size_of_images.width = surface_capabilities.minImageExtent.width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( size_of_images.width &gt;</span><br><span class="line">    surface_capabilities.maxImageExtent.width ) </span><br><span class="line">    &#123;</span><br><span class="line">    	size_of_images.width = surface_capabilities.maxImageExtent.width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( size_of_images.height &lt; surface_capabilities.minImageExtent.height )</span><br><span class="line">    &#123;</span><br><span class="line">    	size_of_images.height = surface_capabilities.minImageExtent.height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( size_of_images.height &gt; surface_capabilities.maxImageExtent.height ) </span><br><span class="line">    &#123;</span><br><span class="line">    	size_of_images.height = surface_capabilities.maxImageExtent.height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这种情况就将surface的size作为images的size</span></span><br><span class="line">    size_of_images = surface_capabilities.currentExtent;<span class="comment">//currentExtent是创建的windows尺寸</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>​    正常情况是将windows size作为images的size,但有的os是swapchain images的尺寸决定的.</p>
<h3 id="select-所需的swapchain-iamges使用场景"><a href="#select-所需的swapchain-iamges使用场景" class="headerlink" title="select 所需的swapchain iamges使用场景"></a>select 所需的swapchain iamges使用场景</h3><p>伴随swapchain创建的images常用作color attachments(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT).也就是说我们想向它们渲染东西(RT).但不限于此.也有其他用处:可以进行采样,在copy操作时作为数据源,或者作为拷贝目标.这些都是在创建swapchain时的不同的使用usages,但是需要检查usages是否支持.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image_usage = desired_usages &amp; surface_capabilities.supportedUsageFlags;</span><br><span class="line">return desired_usages == image_usage;</span><br></pre></td></tr></table></figure>
<h3 id="select-a-transformation-of-swapchain-images"><a href="#select-a-transformation-of-swapchain-images" class="headerlink" title="select a transformation of swapchain images"></a>select a transformation of swapchain images</h3><p>有的(尤其是手机)设备,images能从不同orientations看,有时需要控制图像显示到屏幕上时面向.Vulkan能做到这点,能在显示前指定图像的转换.</p>
<p>相关结构</p>
<p>VkSurfaceTransformFlagBitsKHR</p>
<p>Transformations定义了image在显示到屏幕前如何旋转、镜像.在swapchain创建时,能够指定期望的transformation和presentation engine,并作为显示过程的一部分.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( surface_capabilities.supportedTransforms &amp; desired_transform ) &#123;</span><br><span class="line">surface_transform = desired_transform;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">surface_transform = surface_capabilities.currentTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="select-一种swapchain-images-格式"><a href="#select-一种swapchain-images-格式" class="headerlink" title="select 一种swapchain images 格式"></a>select 一种swapchain images 格式</h3><p>format定义了color分量的数量和每个分量的bits和数据类型.在创建swapchain时</p>
<blockquote>
<p>需要决定使用的颜色通道</p>
<p>是否使用uint或float类型</p>
<p>精度</p>
<p>线性、非线性颜色.</p>
</blockquote>
<p>​    但只能选择被支持的特性.</p>
<p>相关结构</p>
<p>VkFormat</p>
<p>VkColorSpaceKHR</p>
<p>VkSurfaceFormatKHR</p>
<p>VkSurfaceKHR</p>
<p>获得所有支持的formats,调用两次vkGetPhysicalDeviceSurfaceFormatsKHR,存在列表VkSurfaceFormatKHR里,如果只返回一个VK_FORMAT_UNDEFINED,也就是说对format没有限制.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( (<span class="number">1</span> == surface_formats.size()) &amp;&amp;</span><br><span class="line">(VK_FORMAT_UNDEFINED == surface_formats[<span class="number">0</span>].format) ) &#123;</span><br><span class="line">image_format = desired_surface_format.format;</span><br><span class="line">image_color_space = desired_surface_format.colorSpace;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当返回一系列的VkSurfaceFormatKHR时,需要选择image format好color space都支持的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; surface_format : surface_formats ) &#123;</span><br><span class="line"><span class="keyword">if</span>( (desired_surface_format.format == surface_format.format) &amp;&amp;</span><br><span class="line">(desired_surface_format.colorSpace == surface_format.colorSpace) ) &#123;</span><br><span class="line">image_format = desired_surface_format.format;</span><br><span class="line">image_color_space = desired_surface_format.colorSpace;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后,如果期望公式不支持,选择第一个吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image_format = surface_formats[<span class="number">0</span>].format;</span><br><span class="line">image_color_space = surface_formats[<span class="number">0</span>].colorSpace;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Desired format is not supported. Selecting available format -</span></span><br><span class="line"><span class="string">colorspace combination."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建swapchain"><a href="#创建swapchain" class="headerlink" title="创建swapchain"></a>创建swapchain</h3><p>一个swapchain用于显示images到屏幕上.那是一组能被app请求并显示到app窗口上的images.它们有相同的属性(properties).当准备好所有的参数:数量,size,format,swapchain images的使用usage,选择一个支持的先试试modes,就可以创建swapchain了.</p>
<p>一个swapchain是一组Images,伴随swapchain自动创建、销毁.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">VkSwapchainCreateInfoKHR swapchain_create_info = &#123;</span><br><span class="line">VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,</span><br><span class="line"><span class="literal">nullptr</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">presentation_surface,<span class="comment">//surface</span></span><br><span class="line">image_count,<span class="comment">//minImageCount</span></span><br><span class="line">surface_format.format,</span><br><span class="line">surface_format.colorSpace,<span class="comment">//imageColorSpace</span></span><br><span class="line">image_size,</span><br><span class="line"><span class="number">1</span>,<span class="comment">//imageArrayLayers</span></span><br><span class="line">image_usage,</span><br><span class="line">VK_SHARING_MODE_EXCLUSIVE,<span class="comment">//imageSharingMode</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">//queueFamilyIndexCount</span></span><br><span class="line"><span class="literal">nullptr</span>,</span><br><span class="line">surface_transform,</span><br><span class="line">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,</span><br><span class="line">present_mode,</span><br><span class="line">VK_TRUE,</span><br><span class="line">old_swapchain</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreateSwapchainKHR( logical_device,</span><br><span class="line">&amp;swapchain_create_info, <span class="literal">nullptr</span>, &amp;swapchain );</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS != result) ||</span><br><span class="line">(VK_NULL_HANDLE == swapchain) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create a swapchain."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkDestroySwapchainKHR</span><br></pre></td></tr></table></figure>
<p>一个app的窗口只能关联一个swapchain,当创建一个新的swapchain时,需要销毁之前为这个窗口创建的swapchain.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != old_swapchain ) &#123;</span><br><span class="line">vkDestroySwapchainKHR( logical_device, old_swapchain, <span class="literal">nullptr</span> );</span><br><span class="line">old_swapchain = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获得swapchain-images的handles"><a href="#获得swapchain-images的handles" class="headerlink" title="获得swapchain images的handles"></a>获得swapchain images的handles</h3><p>vkGetSwapchainImagesKHR</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> images_count = <span class="number">0</span>;</span><br><span class="line">VkResult result = VK_SUCCESS;</span><br><span class="line">result = vkGetSwapchainImagesKHR( logical_device, swapchain, &amp;images_count,</span><br><span class="line"><span class="literal">nullptr</span> );</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS != result) ||</span><br><span class="line">(<span class="number">0</span> == images_count) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not get the number of swapchain images."</span> &lt;&lt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">swapchain_images.resize( images_count );</span><br><span class="line">result = vkGetSwapchainImagesKHR( logical_device, swapchain, &amp;images_count,</span><br><span class="line">&amp;swapchain_images[<span class="number">0</span>] );</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS != result) ||</span><br><span class="line">(<span class="number">0</span> == images_count) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not enumerate swapchain images."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>驱动可能创建多余创建swapchain时传参数量的images.我们设置了最小数量,但vulkan实现时可能创建更多.</p>
<p>vulkan中,如果想绘制一个image需要有它的handle.需要创建一个包裹image的image view且在创建framebuffer时用到.framebuffer时一组在渲染过程中用到的images.</p>
<p>得到得是一个数而不是handle本身.这个数字表示使用vkGetSwapchainImagesKHR得到的images数组的索引.因此了解images总数、顺序、handles对于正确使用swapchain和images很必要.</p>
<h3 id="创建一个swapchain-R8G8B8A8-format-amp-mailbox显示模式"><a href="#创建一个swapchain-R8G8B8A8-format-amp-mailbox显示模式" class="headerlink" title="创建一个swapchain(R8G8B8A8 format &amp; mailbox显示模式)"></a>创建一个swapchain(R8G8B8A8 format &amp; mailbox显示模式)</h3><p>无transformations,标准color attachment image usage.</p>
<p>已有设施</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VkPhysicalDevice physical_device;</span><br><span class="line">VkSurfaceKHR presentation_surface;</span><br><span class="line">VkDevice logical_device;</span><br><span class="line">VkSwapchainKHR old_swapchain;</span><br><span class="line">VkPresentModeKHR desired_present_mode;</span><br><span class="line">VkSurfaceCapabilitiesKHR surface_capabilities;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32_t number_of_images;</span><br><span class="line">VkExtent2D image_size;</span><br><span class="line">VkImageUsageFlags image_usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">VkPresentModeKHR desired_present_mode;</span><br><span class="line">if( !SelectDesiredPresentationMode( physical_device, presentation_surface,</span><br><span class="line">VK_PRESENT_MODE_MAILBOX_KHR, desired_present_mode ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">VkSurfaceCapabilitiesKHR surface_capabilities;</span><br><span class="line">if( !GetCapabilitiesOfPresentationSurface( physical_device,</span><br><span class="line">presentation_surface, surface_capabilities ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">uint32_t number_of_images;</span><br><span class="line">if( !SelectNumberOfSwapchainImages( surface_capabilities, number_of_images</span><br><span class="line">) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">VkExtent2D image_size;</span><br><span class="line">if( !ChooseSizeOfSwapchainImages( surface_capabilities, image_size ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">if( (0 == image_size.width) ||</span><br><span class="line">(0 == image_size.height) ) &#123;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">VkImageUsageFlags image_usage;</span><br><span class="line">if( !SelectDesiredUsageScenariosOfSwapchainImages( surface_capabilities,</span><br><span class="line">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, image_usage ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">VkSurfaceTransformFlagBitsKHR surface_transform;</span><br><span class="line">SelectTransformationOfSwapchainImages( surface_capabilities,</span><br><span class="line">VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, surface_transform );</span><br><span class="line">VkFormat image_format;</span><br><span class="line">VkColorSpaceKHR image_color_space;</span><br><span class="line">if( !SelectFormatOfSwapchainImages( physical_device, presentation_surface,</span><br><span class="line">&#123; VK_FORMAT_R8G8B8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR &#125;,</span><br><span class="line">image_format, image_color_space ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if( !CreateSwapchain( logical_device, presentation_surface,</span><br><span class="line">number_of_images, &#123; image_format, image_color_space &#125;, image_size,</span><br><span class="line">image_usage, surface_transform, desired_present_mode, old_swapchain,</span><br><span class="line">swapchain ) ) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if( !GetHandlesOfSwapchainImages( logical_device, swapchain,</span><br><span class="line">swapchain_images ) ) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>
<h3 id="获得swapchain-iamge"><a href="#获得swapchain-iamge" class="headerlink" title="获得swapchain iamge"></a>获得swapchain iamge</h3><p>vkGetSwapchainImagesKHR</p>
<p>semaphores和fences</p>
<p>semphores用于同步device的queues.不能用于同步app的commands提交.</p>
<p>fences app</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkResult result;</span><br><span class="line">result = vkAcquireNextImageKHR( logical_device, swapchain, <span class="number">2000000000</span>,</span><br><span class="line">semaphore, fence, &amp;image_index );</span><br><span class="line"><span class="keyword">switch</span>( result ) &#123;</span><br><span class="line"><span class="keyword">case</span> VK_SUCCESS:</span><br><span class="line"><span class="keyword">case</span> VK_SUBOPTIMAL_KHR:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在immediate模式下,可能images都不可用,也就是可能失败.第三个参数是一个超时参数(ns),</p>
<p>如果要让驱动在处理commands前进行等待,semaphore会用到.</p>
<p>app侧等待性能影响更大.</p>
<p>返回值也很重要</p>
<p>如果返回VK_SUBOPTIMAL_KHR,意味着我们能用这个image,但它不再最适合presentation engine.需要重新创建swapchain.但不必立即做.</p>
<p>当返回VK_ERROR_OUT_OF_DATE_KHR时,image就不能用了,我们需要立即重建swapchain.</p>
<p>对于swapchain最后需要注意的时在能使用一张image前,我们需要改变(transition)它的layout,layout时image的内部内存组织–可能跟当前目的不同.如果想用于不同目的就修改它的layout.</p>
<p>比如,用于presentation engine的images必须有VK_IMAGE_LAYOUT_PRESENT_SRC_KHR层.如果用于渲染必须有VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,改变layout的操作称为transition.</p>
<h3 id="present-an-image"><a href="#present-an-image" class="headerlink" title="present an image"></a>present an image</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PresentInfo</span> &#123;</span></span><br><span class="line">    VkSwapchainKHR Swapchain;</span><br><span class="line">    <span class="keyword">uint32_t</span> ImageIndex;<span class="comment">//想显示的image index</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">VkPresentInfoKHR present_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(rendering_semaphores.size()),</span><br><span class="line">    rendering_semaphores.size() &gt; <span class="number">0</span> ? &amp;rendering_semaphores[<span class="number">0</span>] : <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(swapchains.size()),</span><br><span class="line">    swapchains.size() &gt; <span class="number">0</span> ? &amp;swapchains[<span class="number">0</span>] : <span class="literal">nullptr</span>,</span><br><span class="line">    swapchains.size() &gt; <span class="number">0</span> ? &amp;image_indices[<span class="number">0</span>] : <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span></span><br><span class="line">&#125;;</span><br><span class="line">result = vkQueuePresentKHR( <span class="built_in">queue</span>, &amp;present_info );</span><br><span class="line"><span class="keyword">switch</span>( result ) &#123;</span><br><span class="line">    <span class="keyword">case</span> VK_SUCCESS:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在提交image前,需要修改其layout为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR否则presentation engine可能无法显示它.</p>
<p>当提交命令时,rendering_semaphores用于同步</p>
<h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( swapchain ) &#123;</span><br><span class="line">    vkDestroySwapchainKHR( logical_device, swapchain, <span class="literal">nullptr</span> );</span><br><span class="line">    swapchain = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( presentation_surface ) &#123;</span><br><span class="line">    vkDestroySurfaceKHR( instance, presentation_surface, <span class="literal">nullptr</span> );</span><br><span class="line">    presentation_surface = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://noleafnolife.com/2019/04/05/sdk/graphics/vulkan/9.CommandRecordingandDrawing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nolife">
      <meta itemprop="description" content="一个游戏程序员的blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stoner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/05/sdk/graphics/vulkan/9.CommandRecordingandDrawing/" class="post-title-link" itemprop="url">Command Recording and Drawing</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-05 21:16:00 / Modified: 21:20:22" itemprop="dateCreated datePublished" datetime="2019-04-05T21:16:00+08:00">2019-04-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/" itemprop="url" rel="index"><span itemprop="name">sdk</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/" itemprop="url" rel="index"><span itemprop="name">graphics</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/vulkan/" itemprop="url" rel="index"><span itemprop="name">vulkan</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="9-Command-Recording-and-Drawing"><a href="#9-Command-Recording-and-Drawing" class="headerlink" title="9.Command Recording and Drawing"></a>9.Command Recording and Drawing</h1><p>[TOC]</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><blockquote>
<ul>
<li>Clearing a color image</li>
<li>Clearing a depth-stencil image</li>
<li>Clearing render pass attachments</li>
<li>Binding vertex buffers</li>
<li>Binding an index buffer</li>
<li>Providing data to shaders through push constants</li>
<li>Setting viewport state dynamically</li>
<li>Setting scissor state dynamically</li>
<li>Setting line width state dynamically</li>
<li>Setting depth bias state dynamically</li>
<li>Setting blend constants state dynamically</li>
<li>Drawing a geometry</li>
<li>Drawing an indexed geometry</li>
<li>Dispatching compute work</li>
<li>Executing a secondary command buffer inside a primary command buffer</li>
<li>Recording a command buffer that draws a geometry with a dynamic viewport<br>and scissor states</li>
<li>Recording command buffers on multiple threads</li>
<li>Preparing a single frame of animation</li>
<li>Increasing performance through increasing the number of separately rendered<br>frames</li>
</ul>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Vulkan设计为图形和计算API.它的主要目的是允许我们用多个厂商生产的grahpics 硬件生成dynamic images.</p>
<p>已经了解了如何创建和管理资源以及在shaders中使用.了解了不同的shader stages和pipeline objects控制rendering state或分发computational work.最后一件事是需要知道如何绘制images的知识.</p>
<p>本文讨论commands.受线学习drawing commands和在我们的source code里管理它们以达到最高性能.最后vulkan API里最强力的能力–在多线程进行record command buffers.</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="Clearing-a-color-image"><a href="#Clearing-a-color-image" class="headerlink" title="Clearing a color image"></a>Clearing a color image</h3><p>vulkan里,给render pass的attachment description设置loadOp为VK_ATTACHMENT_LOAD_OP_CLEAR以clear.</p>
<p>有时,我们不想这么做,需要隐式实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vkCmdClearColorImage( command_buffer, image, image_layout, &amp;clear_color,</span><br><span class="line">                     <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(image_subresource_ranges.size()),</span><br><span class="line">                     image_subresource_ranges.data() );</span><br></pre></td></tr></table></figure>
<p>提供image的handle,layout,sub-resources的数组(mipmap level and/or array layers).</p>
<p>只能清理color image.以及transfer dst usage images.</p>
<h3 id="Clearing-a-depth-stencil-image"><a href="#Clearing-a-depth-stencil-image" class="headerlink" title="Clearing a depth-stencil image"></a>Clearing a depth-stencil image</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vkCmdClearDepthStencilImage( command_buffer, image, image_layout,</span><br><span class="line">                            &amp;clear_value, <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(image_subresource_ranges.size()),</span><br><span class="line">                            image_subresource_ranges.data() );</span><br></pre></td></tr></table></figure>
<p>VkClearDepthStencilValue</p>
<blockquote>
<ul>
<li>depth when a depth aspect should be cleared</li>
<li>stencil for a value used to clear the stencil aspect</li>
</ul>
</blockquote>
<h3 id="Clearing-render-pass-attachments"><a href="#Clearing-render-pass-attachments" class="headerlink" title="Clearing render pass attachments"></a>Clearing render pass attachments</h3><p>vkCmdClearAttachments</p>
<p>有时清理attachements of sub-passes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vkCmdClearAttachments( command_buffer,</span><br><span class="line">                      <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(attachments.size()), attachments.data(),</span><br><span class="line">                      <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(rects.size()), rects.data() );</span><br></pre></td></tr></table></figure>
<p>VkClearAttachment</p>
<blockquote>
<ul>
<li>aspectMask attachment的aspect(color,depth,stencil)</li>
<li>aspectMask 置为VK_IMAGE_ASPECT_COLOR_BIT,指明colorAttachment为当前sub-pass里的color attachemnt,否则忽略</li>
<li>clearValue</li>
</ul>
</blockquote>
<p>VkClearRect</p>
<blockquote>
<ul>
<li>top-left,width,height</li>
</ul>
</blockquote>
<h3 id="Binding-vertex-buffers"><a href="#Binding-vertex-buffers" class="headerlink" title="Binding vertex buffers"></a>Binding vertex buffers</h3><p>当进行几何绘制需要指明vertiices数据.至少需要vertex positions(其实也不是必须的,可以shader里生成…).其他数据还有normal,tangent/bitangent,colors,teexture coordinates.这些数据来源于usage为vertex buffer的buffers.需要在dc前绑定这些buffers.</p>
<p>VertexBufferParameters</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexBufferParameters</span> &#123;</span></span><br><span class="line">    VkBuffer Buffer;</span><br><span class="line">    VkDeviceSize MemoryOffset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VertexBufferParameters&gt; named buffers_parameters.</span><br><span class="line">    ..</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkBuffer&gt; buffers;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkDeviceSize&gt; offsets;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; buffer_parameters : buffers_parameters ) &#123;</span><br><span class="line">    buffers.push_back( buffer_parameters.Buffer );</span><br><span class="line">    offsets.push_back( buffer_parameters.MemoryOffset );</span><br><span class="line">&#125;</span><br><span class="line">vkCmdBindVertexBuffers( command_buffer, first_binding,</span><br><span class="line">                       <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(buffers_parameters.size()), buffers.data(),</span><br><span class="line">                       offsets.data() );</span><br></pre></td></tr></table></figure>
<h3 id="Binding-an-index-buffer"><a href="#Binding-an-index-buffer" class="headerlink" title="Binding an index buffer"></a>Binding an index buffer</h3><p>index buffer的usage为index buffer，type为，比如VK_INDEX_TYPE_UINT16，VK_INDEX_TYPE_UINT32</p>
<p><img src="media/indexbuffer.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkCmdBindIndexBuffer( command_buffer, buffer, memory_offset, index_type );</span><br></pre></td></tr></table></figure>
<h3 id="Providing-data-to-shaders-through-push-constants"><a href="#Providing-data-to-shaders-through-push-constants" class="headerlink" title="Providing data to shaders through push constants"></a>Providing data to shaders through push constants</h3><p>大多数时间使用descriptor set通过buffers或images提供大量数据.为了快速方便提供数据给shader,可以使用push constants.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vkCmdPushConstants( command_buffer, </span><br><span class="line">                   pipeline_layout,</span><br><span class="line">                   pipeline_stages, </span><br><span class="line">                   offset,<span class="comment">//4的倍数 </span></span><br><span class="line">                   size, <span class="comment">//4的倍数</span></span><br><span class="line">                   data <span class="comment">//void*</span></span><br><span class="line">                   )</span><br></pre></td></tr></table></figure>
<p>硬件最少支持128bytes.</p>
<p>一个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">float</span>, 4&gt; color = &#123; <span class="number">0.0f</span>, <span class="number">0.7f</span>, <span class="number">0.4f</span>, <span class="number">0.1f</span> &#125;;</span><br><span class="line">ProvideDataToShadersThroughPushConstants( CommandBuffer, *PipelineLayout,</span><br><span class="line">                                         VK_SHADER_STAGE_FRAGMENT_BIT, <span class="number">0</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">sizeof</span>( color[<span class="number">0</span>] ) *</span><br><span class="line">color.size()), &amp;color[<span class="number">0</span>] );</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProvideDataToShadersThroughPushConstants(...)</span><br><span class="line">&#123;</span><br><span class="line">	vkCmdPushConstants( command_buffer, pipeline_layout, pipeline_stages,</span><br><span class="line">offset, size, data );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><h3 id="Setting-viewport-state-dynamically"><a href="#Setting-viewport-state-dynamically" class="headerlink" title="Setting viewport state dynamically"></a>Setting viewport state dynamically</h3><p>VkViewport</p>
<blockquote>
<ul>
<li>left :up left for x</li>
<li>top: up left for y</li>
<li>width </li>
<li>height</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; vkCmdSetViewport( command_buffer, first_viewport,</span><br><span class="line">&gt;                  <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(viewports.size()), viewports.data() );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>stages dynamic指明是动态的,但数量是创建时就固定了的</p>
<h3 id="Setting-scissor-state-dynamically"><a href="#Setting-scissor-state-dynamically" class="headerlink" title="Setting scissor state dynamically"></a>Setting scissor state dynamically</h3><p>scissor额外再viewport dimentsion内添加了一个渲染rectangle区域.总开启.可以静态设置,也可以cb动态设置</p>
<p>VkRect2D</p>
<blockquote>
<ul>
<li>x:horizontal offset (in pixels) from up left corner of viewport for x number of offset</li>
<li>y:upper left corner</li>
<li>width</li>
<li>height</li>
</ul>
<p>vkCmdSetScissor</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; vkCmdSetScissor( command_buffer, first_scissor,</span><br><span class="line">&gt;                 <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(scissors.size()), scissors.data() );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<h3 id="Setting-line-width-states-dynamically"><a href="#Setting-line-width-states-dynamically" class="headerlink" title="Setting line width states dynamically"></a>Setting line width states dynamically</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkCmdSetLineWidth( command_buffer, line_width )</span><br></pre></td></tr></table></figure>
<h3 id="Setting-depth-bias-state-dynamically"><a href="#Setting-depth-bias-state-dynamically" class="headerlink" title="Setting depth bias state dynamically"></a>Setting depth bias state dynamically</h3><p>depth bias可以修正fragment的depth value计算.</p>
<p>depth bias可以对fragment的depth进行offset.通常绘制非常近的objects用到.比如墙上的pictures or posters.这类objects绘制会有z-fighting.</p>
<p>depth bias修正value计算–存储在depth attachment里的depth value.但不会影响渲染的image.也就是不会影响距离感.修正是基于constant factor和fragment的slope.也指明depth bias(clamp)能加的最大或最小值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkCmdSetDepthBias( command_buffer, constant_factor, clamp, slope_factor );</span><br></pre></td></tr></table></figure>
<h3 id="Setting-blend-constants-states-dynamically"><a href="#Setting-blend-constants-states-dynamically" class="headerlink" title="Setting blend constants states dynamically"></a>Setting blend constants states dynamically</h3><p>blend用于透明物体模拟.通过控制混合英子和操作,得到最终结果.也可以使用constant color进行计算.constant color可以动态设置.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkCmdSetBlendConstants( command_buffer, blend_constants.data() );</span><br></pre></td></tr></table></figure>
<h2 id="drawing"><a href="#drawing" class="headerlink" title="drawing"></a>drawing</h2><h3 id="Drawing-a-geometry"><a href="#Drawing-a-geometry" class="headerlink" title="Drawing a geometry"></a>Drawing a geometry</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vkCmdDraw( command_buffer, </span><br><span class="line">          vertex_count, </span><br><span class="line">          instance_count, </span><br><span class="line">          first_vertex,<span class="comment">//多models存储到一个vertex buffer里有用</span></span><br><span class="line">          first_instance</span><br><span class="line">          );</span><br></pre></td></tr></table></figure>
<p>instance在不改变vertex进行通mesh绘制很有用(ref specifying pipeline vertex binding description,attribute description,and input state,chapter 8,graphics and compute piipeline).</p>
<p><img src="media/vkCmdDrawInstance.png" alt></p>
<p>vulkan里没有Default state.</p>
<p>比如descriptor sets或dynamic pipeline states.每次record cb,所有需求的descriptor sets需要绑定给成本，类似作为dynamic的pipeline state必须用对于函数提供值,render pass必须在合适的command buffer里开始.</p>
<p>drawing cam be performed only inside the render pass.</p>
<h3 id="Drawing-an-indexed-geometry"><a href="#Drawing-an-indexed-geometry" class="headerlink" title="Drawing an indexed geometry"></a>Drawing an indexed geometry</h3><p>最常用的.</p>
<p>vkCmdDrawIndexed()</p>
<p>去重复顶点,需要额外的index buffer.但在vertex有很多额外数据时很有必要(normal,tangent,bitangent,two texture coordinates).</p>
<p>$\color {red}{新的概念(reuse vertex)}$:Indexed drawing允许硬件重用vertex caching里已经计算的vertices.根据indices,如果已经计算过,reuse.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vkCmdDrawIndexed( command_buffer, index_count, instance_count, first_index,</span><br><span class="line">                 vertex_offset, first_instance );</span><br></pre></td></tr></table></figure>
<h3 id="Dispatching-compute-work"><a href="#Dispatching-compute-work" class="headerlink" title="Dispatching compute work"></a>Dispatching compute work</h3><p>compute pipeline</p>
<p>resource通过且只能通过descriptor sets</p>
<p>可用来进行image post-processing,color correction or blur.physical 计算.</p>
<p>compute shaderdispatched in groups.</p>
<p>vkCmdDispatch( command_buffer, x_size, y_size, z_size );</p>
<p>workgroups</p>
<p>maxComputeWorkGroupCount[3]</p>
<p>硬件最少支持65,535</p>
<p>不能再render passes里进行</p>
<h3 id="Executing-a-secondary-command-buffer-inside-a-primary-command-buffer"><a href="#Executing-a-secondary-command-buffer-inside-a-primary-command-buffer" class="headerlink" title="Executing a secondary command buffer inside a primary command buffer"></a>Executing a secondary command buffer inside a primary command buffer</h3><p>vulkan里可以record2中command buffers-primary and secondary.primary command buffers能直接submit到queues.secondary command buffers只能在primary command buffer里执行.</p>
<p>vkCmdExecuteCommands</p>
<p>一般primary command buffers已经足够用来rendering或computing work.但是有时需要把工作分到两种command buffer 里.当想图形硬件执行secondary command buffers时我们能在primary command buffer里这样做:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vkCmdExecuteCommands( command_buffer,</span><br><span class="line">                     <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(secondary_command_buffers.size()),</span><br><span class="line">                     secondary_command_buffers.data() );</span><br></pre></td></tr></table></figure>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><h3 id="Recording-a-command-buffer-that-draws-a-geometry-with-a-dynamic-viewport-and-scissor-states"><a href="#Recording-a-command-buffer-that-draws-a-geometry-with-a-dynamic-viewport-and-scissor-states" class="headerlink" title="Recording a command buffer that draws a geometry with a dynamic viewport and scissor states"></a>Recording a command buffer that draws a geometry with a dynamic viewport and scissor states</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; Data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; VertexOffset;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; VertexCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !BeginCommandBufferRecordingOperation( command_buffer,</span><br><span class="line">                                          VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, <span class="literal">nullptr</span> ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>image memory barrier</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( present_queue_family_index != graphics_queue_family_index ) &#123;</span><br><span class="line">    ImageTransition image_transition_before_drawing = &#123;</span><br><span class="line">        swapchain_image,</span><br><span class="line">        VK_ACCESS_MEMORY_READ_BIT,</span><br><span class="line">        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,</span><br><span class="line">        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,</span><br><span class="line">        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,</span><br><span class="line">        present_queue_family_index,</span><br><span class="line">        graphics_queue_family_index,</span><br><span class="line">        VK_IMAGE_ASPECT_COLOR_BIT</span><br><span class="line">    &#125;;</span><br><span class="line">    SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,</span><br><span class="line">                          VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, &#123;</span><br><span class="line">                              image_transition_before_drawing &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start render pass,bind pipeline object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeginRenderPass( command_buffer, render_pass, framebuffer, &#123; &#123; <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">                                                            framebuffer_size &#125;, clear_values, VK_SUBPASS_CONTENTS_INLINE );</span><br><span class="line">BindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS,</span><br><span class="line">                   graphics_pipeline );</span><br></pre></td></tr></table></figure>
<p>设置dynamic states.viewport ,scissor..bind a buffer for vertex data</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">VkViewport viewport = &#123;</span><br><span class="line">    <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(framebuffer_size.width),</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(framebuffer_size.height),</span><br><span class="line">    <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line">SetViewportStateDynamically( command_buffer, <span class="number">0</span>, &#123; viewport &#125; );</span><br><span class="line">VkRect2D scissor = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        framebuffer_size.width,</span><br><span class="line">        framebuffer_size.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">SetScissorStateDynamically( command_buffer, <span class="number">0</span>, &#123; scissor &#125; );</span><br><span class="line">BindVertexBuffers( command_buffer, first_vertex_buffer_binding,</span><br><span class="line">                  vertex_buffers_parameters );</span><br></pre></td></tr></table></figure>
<p>descriptor sets,shaders访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BindDescriptorSets( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS,</span><br><span class="line">                   pipeline_layout, index_for_first_descriptor_set, descriptor_sets, &#123;&#125; );</span><br></pre></td></tr></table></figure>
<p>现在可以绘制几何体了.当然还可以设置index buffer,提供push constants值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; geometry.Parts.size(); ++i ) &#123;</span><br><span class="line">    DrawGeometry( command_buffer, geometry.Parts[i].VertexCount,</span><br><span class="line">                 instance_count, geometry.Parts[i].VertexOffset, first_instance );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在停止record command buffer前,需要end render pass.之后需要另一个transition on a swapchain image.当完成在single frame of animation上进行绘制,想要在swapchain image上显示.为此需要改变它的layout为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,因为这是presentation engine正确显示image要求的.这个不走需要显示进行.</p>
<p>$\color{red}{注意}$,如果用于graphics operations和presentations的queues不同,需要一个queue ownership transfer.这通过另一个image memory barrier完成.之后,我们能停止record a command buffer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EndRenderPass( command_buffer );</span><br><span class="line"><span class="keyword">if</span>( present_queue_family_index != graphics_queue_family_index ) &#123;</span><br><span class="line">    ImageTransition image_transition_before_present = &#123;</span><br><span class="line">        swapchain_image,</span><br><span class="line">        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,</span><br><span class="line">        VK_ACCESS_MEMORY_READ_BIT,</span><br><span class="line">        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,</span><br><span class="line">        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,</span><br><span class="line">        graphics_queue_family_index,</span><br><span class="line">        present_queue_family_index,</span><br><span class="line">        VK_IMAGE_ASPECT_COLOR_BIT</span><br><span class="line">    &#125;;</span><br><span class="line">    SetImageMemoryBarrier( command_buffer,</span><br><span class="line">                          VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,</span><br><span class="line">                          VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, &#123; image_transition_before_present &#125;</span><br><span class="line">                         );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !EndCommandBufferRecordingOperation( command_buffer ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>我们能用这个cb并submit it to a (graphic) queue.只能submit一次,因为flag 为VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT.</p>
<p>submit这个cb之后,能显示到swapchain image上.需要注意submission和presentation operations需要进行同步</p>
<h3 id="advanced"><a href="#advanced" class="headerlink" title="advanced"></a>advanced</h3><h3 id="Recording-command-buffers-on-multiple-threads"><a href="#Recording-command-buffers-on-multiple-threads" class="headerlink" title="*Recording command buffers on multiple threads"></a>*Recording command buffers on multiple threads</h3><p>自定义结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CommandBufferRecordingThreadParameters</span> &#123;</span></span><br><span class="line">    VkCommandBuffer CommandBuffer;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>( VkCommandBuffer )&gt; RecordingFunction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个线程一个,记录cbs.RecordingFunction定义了一个在独立thread里record command buffer的function.</p>
<p>为了多线程使用vulkan,需要记住一些规则.</p>
<p>第一不能再多线程修改同一个object.比如不能再多线程从同一个pool allocate command buffers或不能从多线程更新descriptor set.</p>
<p>只有再资源时只读的或者时访问分开的资源吗,我们能从多线程访问.但很难追踪哪个资源时哪个线程创建的.通常,资源创建和修改再主线程(rendering thread).</p>
<p>在Vulkan中使用多线程最常见的场景是并发地记录命令缓冲区.这个操作花费大量时间,分开到多线程进行时很有道理的.</p>
<p>当多线程进行record command buffers时需要多线程和每个线程对应一个独立的command pool</p>
<p>command buffer recording不影响其他资源(除了pool).只准备给一个queue submit commands,所以能record任何操作使用任何资源.比如记录多个操作访问同样的图片或descriptor sets.同样的pipelines能同时绑定不同的command buffers.我们也能record operations绘制到同样的attachments里.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads( threads_parameters.size() );</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads_parameters.size(); ++i ) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread::thread(</span><br><span class="line">        threads_parameters[i].RecordingFunction,</span><br><span class="line">        threads_parameters[i].CommandBuffer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有thread完成record cbs后需要收集到一起然后submit它们到queue.</p>
<p>真实app里会避免这样创建和销毁threads的方式.相反,使用已有的job/task system并使用它们record需要的cbs.如图.</p>
<p>submission只能再单线程进行(queus,similarly to other resources,cannot be accessed concurrently),需要等待所有线程完成.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkCommandBuffer&gt; command_buffers( threads_parameters.size() );</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads_parameters.size(); ++i ) &#123;</span><br><span class="line">    threads[i].join();</span><br><span class="line">    command_buffers[i] = threads_parameters[i].CommandBuffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !SubmitCommandBuffersToQueue( <span class="built_in">queue</span>, wait_semaphore_infos,</span><br><span class="line">                                 command_buffers, signal_semaphores, fence ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>submitting cbs一次只能再一个线程进行.</p>
<p><img src="media/multithreadcbs.png" alt></p>
<p>swapchain object也会发生同样的情况.同时只能在一个线程acquire和present swapchain images.</p>
<p>需要留意将layout 从VK_IMAGE_LAYOUT_PRESENT_SRC_KHR (or VK_IMAGE_LAYOUT_UNDEFINED)转换为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR.</p>
<h3 id="Preparing-a-single-frame-of-animation"><a href="#Preparing-a-single-frame-of-animation" class="headerlink" title="Preparing a single frame of animation"></a>Preparing a single frame of animation</h3><p>Preparing a single frame of animation can be divided into five steps:</p>
<ol>
<li>Acquiring a swapchain image.</li>
<li>Creating a framebuffer.</li>
<li>Recording a command buffer.</li>
<li>Submitting the command buffer to the queue.</li>
<li>Presenting an image.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> image_index;</span><br><span class="line"><span class="keyword">if</span>( !AcquireSwapchainImage( logical_device, swapchain,</span><br><span class="line">                           image_acquired_semaphore, VK_NULL_HANDLE, image_index ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkImageView&gt; attachments = &#123; swapchain_image_views[image_index]</span><br><span class="line">                                       &#125;;</span><br><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != depth_attachment ) &#123;</span><br><span class="line">    attachments.push_back( depth_attachment );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !CreateFramebuffer( logical_device, render_pass, attachments,</span><br><span class="line">                       swapchain_size.width, swapchain_size.height, <span class="number">1</span>, *framebuffer ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !record_command_buffer( command_buffer, image_index, *framebuffer ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;WaitSemaphoreInfo&gt; wait_semaphore_infos = wait_infos;</span><br><span class="line">wait_semaphore_infos.push_back( &#123;</span><br><span class="line">    image_acquired_semaphore,</span><br><span class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span><br><span class="line">&#125; );</span><br><span class="line"><span class="keyword">if</span>( !SubmitCommandBuffersToQueue( graphics_queue, wait_semaphore_infos, &#123;</span><br><span class="line">    command_buffer &#125;, &#123; ready_to_present_semaphore &#125;, finished_drawing_fence )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">PresentInfo present_info = &#123;</span><br><span class="line">    swapchain,</span><br><span class="line">    image_index</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>( !PresentImage( present_queue, &#123; ready_to_present_semaphore &#125;, &#123;</span><br><span class="line">    present_info &#125; ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>fence用于GPU确定cb结束</p>
<h3 id="Increasing-performance-through-increasing-the-number-of-separately-rendered-frames"><a href="#Increasing-performance-through-increasing-the-number-of-separately-rendered-frames" class="headerlink" title="*Increasing performance through increasing the number of separately rendered frames"></a>*Increasing performance through increasing the number of separately rendered frames</h3><p>在等待cb 运行结束这段时间是浪费了的.所以需要独立render multiple frames of animation .</p>
<p>自定义结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FrameResources</span> &#123;</span></span><br><span class="line">    VkCommandBuffer CommandBuffer;<span class="comment">//单帧独立的comman buffer</span></span><br><span class="line">    VkDestroyer&lt;VkSemaphore&gt; ImageAcquiredSemaphore;<span class="comment">//给presentation engine的信号量</span></span><br><span class="line">    VkDestroyer&lt;VkSemaphore&gt; ReadyToPresentSemaphore;<span class="comment">//用于知道queue停止运行该cb</span></span><br><span class="line">    VkDestroyer&lt;VkFence&gt; DrawingFinishedFence;<span class="comment">//当signaled表示GPU运行完了</span></span><br><span class="line">    VkDestroyer&lt;VkImageView&gt; DepthAttachment;<span class="comment">//</span></span><br><span class="line">    VkDestroyer&lt;VkFramebuffer&gt; Framebuffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用于管理单帧生命周期内管理的资源.</p>
<p>rendering animation是要给循环.一帧绘制,一帧显示.</p>
<p>需要准备多份set</p>
<p><img src="media/renderingframesofanimation.png" alt></p>
<p>Tests have shown that increasing the number of frame resources from one to two may increase the performance by 50%.</p>
<p>Adding a third set increases the performance further, but the growth isn’t as big this time.</p>
<p>So, the performance gain is smaller with each additional set of frame resources. Three sets of rendering resources seems like a good choice, but we should perform our own tests and see what is best for our specific needs.</p>
<p><img src="media/renderframeofanimationsets.png" alt></p>
<p>check</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> frame_index = <span class="number">0</span>;</span><br><span class="line">FrameResources &amp; current_frame = frame_resources[frame_index];</span><br><span class="line"><span class="keyword">if</span>( !WaitForFences( logical_device, &#123; *current_frame.DrawingFinishedFence</span><br><span class="line">                                    &#125;, <span class="literal">false</span>, <span class="number">2000000000</span> ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !ResetFences( logical_device, &#123; *current_frame.DrawingFinishedFence &#125; )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InitVkDestroyer( logical_device, current_frame.Framebuffer );</span><br><span class="line"><span class="keyword">if</span>( !PrepareSingleFrameOfAnimation( logical_device, graphics_queue,</span><br><span class="line">                                   present_queue, swapchain, swapchain_size, swapchain_image_views,</span><br><span class="line">                                   *current_frame.DepthAttachment, wait_infos,</span><br><span class="line">                                   *current_frame.ImageAcquiredSemaphore,</span><br><span class="line">                                   *current_frame.ReadyToPresentSemaphore,</span><br><span class="line">                                   *current_frame.DrawingFinishedFence, record_command_buffer,</span><br><span class="line">                                   current_frame.CommandBuffer, render_pass, current_frame.Framebuffer ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">frame_index = (frame_index + <span class="number">1</span>) % frame_resources.size();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://noleafnolife.com/2019/04/05/sdk/graphics/vulkan/5.DescriptorSets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nolife">
      <meta itemprop="description" content="一个游戏程序员的blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stoner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/05/sdk/graphics/vulkan/5.DescriptorSets/" class="post-title-link" itemprop="url">Descriptor Sets</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-05 21:16:00 / Modified: 21:19:43" itemprop="dateCreated datePublished" datetime="2019-04-05T21:16:00+08:00">2019-04-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/" itemprop="url" rel="index"><span itemprop="name">sdk</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/" itemprop="url" rel="index"><span itemprop="name">graphics</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/vulkan/" itemprop="url" rel="index"><span itemprop="name">vulkan</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="Descriptor-Sets"><a href="#Descriptor-Sets" class="headerlink" title="Descriptor Sets"></a>Descriptor Sets</h1><p>[TOC]</p>
<p>Creating a sampler<br>Creating a sampled image<br>Creating a combined image sampler<br>Creating a storage image<br>Creating a uniform texel buffer<br>Creating a storage texel buffer<br>Creating a uniform buffer<br>Creating a storage buffer<br>Creating an input attachment<br>Creating a descriptor set layout<br>Creating a descriptor pool<br>Allocating descriptor sets<br>Updating descriptor sets<br>Binding descriptor sets<br>Creating descriptors with a texture and a uniform buffer<br>Freeing descriptor sets<br>Resetting a descriptor pool<br>Destroying a descriptor pool<br>Destroying a descriptor set layout<br>Destroying a sampler</p>
<p>在现代计算机图形学领域,多数image数据(vertices,pixels,fragments,voxel)的渲染和执行都是通过可编程pipeline和shaders实现.相关的:textures,samplers,buffers,uniform variables.在vulkan里这些通过descriptor sets提供.</p>
<p>Descriptors表示shader resources的不透明的structures.有descriptor set layouts指明内容,组织成groups或sets.为了给shaders提供资源,给Pipelines绑定descriptor sets.我们能一次绑定多个sets.为了从shaders内部访问resources,我们需要指定从哪个set以及从set中的哪个位置（称为binding）获取给定资源.</p>
<h2 id="sampler"><a href="#sampler" class="headerlink" title="sampler"></a>sampler</h2><h3 id="create-a-sampler"><a href="#create-a-sampler" class="headerlink" title="create a sampler"></a>create a sampler</h3><p>Samplers定义了image data加载到shader里的一组参数.包括address caculations(wrapping or repeating)、filtering(linear or nearest)、use mipmaps.</p>
<p>VkSamplerCreateInfo</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VkSamplerCreateInfo sampler_create_info = &#123;</span><br><span class="line">	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    mag_filter,</span><br><span class="line">    min_filter,</span><br><span class="line">    mipmap_mode,</span><br><span class="line">    u_address_mode,</span><br><span class="line">    v_address_mode,</span><br><span class="line">    w_address_mode,</span><br><span class="line">    lod_bias,</span><br><span class="line">    anisotropy_enable,</span><br><span class="line">    max_anisotropy,</span><br><span class="line">    compare_enable,</span><br><span class="line">    compare_operator,</span><br><span class="line">    min_lod,</span><br><span class="line">    max_lod,</span><br><span class="line">    border_color,</span><br><span class="line">    unnormalized_coords</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkCreateSampler( logical_device, &amp;sampler_create_info,</span><br><span class="line"><span class="literal">nullptr</span>, &amp;sampler );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create sampler."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>为了在shader里指明samplr,需要创建一个sampler uniform 变量</p>
<p>形如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (<span class="built_in">set</span>=m, binding=n) uniform sampler &lt;variable name&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="create-a-sampled-image"><a href="#create-a-sampled-image" class="headerlink" title="create a sampled image"></a>create a sampled image</h3><p>sampled images用于在shaders里从images(textures)读取数据.通常是一起创建,VK_IMAGE_USAGE_SAMPLED_BIT usage.</p>
<p>在shaders里,我们能用多个samplers按照不同方式读取同一个image.也能一个sampler对应多个images.但有些平台,二者是何为一个obj的.</p>
<p>不是所有image foramt都支持sampled iamges.这依赖于app执行平台.下列是总能用于sampled images和linearly filtered sampled images的formats.不限于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VK_FORMAT_B4G4R4A4_UNORM_PACK16</span><br><span class="line">VK_FORMAT_R5G6B5_UNORM_PACK16</span><br><span class="line">VK_FORMAT_A1R5G5B5_UNORM_PACK16</span><br><span class="line">VK_FORMAT_R8_UNORM and VK_FORMAT_R8_SNORM</span><br><span class="line">VK_FORMAT_R8G8_UNORM and VK_FORMAT_R8G8_SNORM</span><br><span class="line">VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SNORM, and</span><br><span class="line">VK_FORMAT_R8G8B8A8_SRGB</span><br><span class="line">VK_FORMAT_B8G8R8A8_UNORM and VK_FORMAT_B8G8R8A8_SRGB</span><br><span class="line">VK_FORMAT_A8B8G8R8_UNORM_PACK32, VK_FORMAT_A8B8G8R8_SNORM_PACK32,</span><br><span class="line">and VK_FORMAT_A8B8G8R8_SRGB_PACK32</span><br><span class="line">VK_FORMAT_A2B10G10R10_UNORM_PACK32</span><br><span class="line">VK_FORMAT_R16_SFLOAT</span><br><span class="line">VK_FORMAT_R16G16_SFLOAT</span><br><span class="line">VK_FORMAT_R16G16B16A16_SFLOAT</span><br><span class="line">VK_FORMAT_B10G11R11_UFLOAT_PACK32</span><br><span class="line">VK_FORMAT_E5B9G9R9_UFLOAT_PACK32</span><br></pre></td></tr></table></figure>
<p>其他格式性需要自己检查一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VkFormatProperties format_properties;</span><br><span class="line">vkGetPhysicalDeviceFormatProperties( physical_device, format,</span><br><span class="line">&amp;format_properties );</span><br><span class="line"><span class="keyword">if</span>( !(format_properties.optimalTilingFeatures &amp;</span><br><span class="line">VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Provided format is not supported for a sampled image."</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( linear_filtering &amp;&amp;</span><br><span class="line">!(format_properties.optimalTilingFeatures &amp;</span><br><span class="line">VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT) ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Provided format is not supported for a linear image</span></span><br><span class="line"><span class="string">    filtering."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果满足需求,可以创建一个image,一个memory object,一个image view(vulkan中images are represented with iamge views most of the time).指明usage为VK_IMAGE_USAGE_SAMPLED_BIT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateImage( logical_device, type, format, size, num_mipmaps,</span><br><span class="line">num_layers, VK_SAMPLE_COUNT_1_BIT, usage | VK_IMAGE_USAGE_SAMPLED_BIT,</span><br><span class="line"><span class="literal">false</span>, sampled_image ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device,</span><br><span class="line">sampled_image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !CreateImageView( logical_device, sampled_image, view_type, format,</span><br><span class="line">aspect, sampled_image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>当想用一个image作为sampled image,在加载数据到shaders前,我们需要变换image的layout为VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL.</p>
<p>shader里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (set=m, binding=n) uniform texture2D &lt;variable name&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="create-a-combined-image-sampler"><a href="#create-a-combined-image-sampler" class="headerlink" title="create a combined image sampler"></a>create a combined image sampler</h3><p>创建和分开时是一样的,只是shaders里不一样.descriptor为VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateSampler( logical_device, mag_filter, min_filter, mipmap_mode,</span><br><span class="line">u_address_mode, v_address_mode, w_address_mode, lod_bias,</span><br><span class="line">anisotropy_enable, max_anisotropy, compare_enable, compare_operator,</span><br><span class="line">min_lod, max_lod, border_color, unnormalized_coords, sampler ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> linear_filtering = (mag_filter == VK_FILTER_LINEAR) || (min_filter ==</span><br><span class="line">VK_FILTER_LINEAR) || (mipmap_mode == VK_SAMPLER_MIPMAP_MODE_LINEAR);</span><br><span class="line"><span class="keyword">if</span>( !CreateSampledImage( physical_device, logical_device, type, format,</span><br><span class="line">size, num_mipmaps, num_layers, usage, view_type, aspect, linear_filtering,</span><br><span class="line">sampled_image, sampled_image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>使用sampler关键词</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (<span class="built_in">set</span>=m, binding=n) uniform sampler2D &lt;variable name&gt;;</span><br></pre></td></tr></table></figure>
<p>有些平台性能更好.</p>
<h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><h3 id="create-a-storage-image"><a href="#create-a-storage-image" class="headerlink" title="create a storage image"></a>create a storage image</h3><p>storage image允许我们从images里加载数据到Pipelines,也可以从shader存储数据到images.这类images需要指明usage为VK_IMAGE_USAGE_STORAGE_BIT</p>
<p>虽然可以从这类images里load数据,单数据是unfiltered(所以不能sampler)</p>
<p>descriptors type为VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</p>
<p>需要指明合适的格式,不是所有格式都支持storage images.与平台相关,单下列是都支持的(not limited).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SNORM,</span><br><span class="line">VK_FORMAT_R8G8B8A8_UINT, <span class="keyword">and</span> VK_FORMAT_R8G8B8A8_SINT</span><br><span class="line">VK_FORMAT_R16G16B16A16_UINT, VK_FORMAT_R16G16B16A16_SINT <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R16G16B16A16_SFLOAT</span><br><span class="line">VK_FORMAT_R32_UINT, VK_FORMAT_R32_SINT <span class="keyword">and</span> VK_FORMAT_R32_SFLOAT</span><br><span class="line">VK_FORMAT_R32G32_UINT, VK_FORMAT_R32G32_SINT <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R32G32_SFLOAT</span><br><span class="line">VK_FORMAT_R32G32B32A32_UINT, VK_FORMAT_R32G32B32A32_SINT <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R32G32B32A32_SFLOAT</span><br></pre></td></tr></table></figure>
<p>如果想要原子操作,只能用如下格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VK_FORMAT_R32_UINT</span><br><span class="line">VK_FORMAT_R32_SINT</span><br></pre></td></tr></table></figure>
<p>如果想用其他的,需要检查是否支持或是否支持原子操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VkFormatProperties format_properties;</span><br><span class="line">vkGetPhysicalDeviceFormatProperties( physical_device, format,</span><br><span class="line">&amp;format_properties );</span><br><span class="line"><span class="keyword">if</span>( !(format_properties.optimalTilingFeatures &amp;</span><br><span class="line">VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Provided format is not supported for a storage image."</span> &lt;&lt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( atomic_operations &amp;&amp;</span><br><span class="line">!(format_properties.optimalTilingFeatures &amp;</span><br><span class="line">VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Provided format is not supported for atomic operations on</span></span><br><span class="line"><span class="string">storage images."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果支持,如常创建images.指明usage为VK_IMAGE_USAGE_STORAGE_BIT,然后创建memory object,绑定都image,然后是image view.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateImage( logical_device, type, format, size, num_mipmaps,</span><br><span class="line">num_layers, VK_SAMPLE_COUNT_1_BIT, usage | VK_IMAGE_USAGE_STORAGE_BIT,</span><br><span class="line"><span class="literal">false</span>, storage_image ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device,</span><br><span class="line">storage_image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !CreateImageView( logical_device, storage_image, view_type, format,</span><br><span class="line">aspect, storage_image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>在load/store数据前需要设置layout为VK_IMAGE_LAYOUT_GENERAL.这是这些操作为唯一支持的layout.</p>
<p>GLSL的storage images定义的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (<span class="built_in">set</span>=m, binding=n, r32f) uniform image2D &lt;variable name&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="create-uniform-texel-buffer"><a href="#create-uniform-texel-buffer" class="headerlink" title="create uniform texel buffer"></a>create uniform texel buffer</h3><p>uniform texel buffer允许我们想从images里读取数据一样,他们的内容不是一个单值(scalar)的数组,而是格式化整个为pixels(texel)(1,2,3,4种分项).能比images访问更多的数据.</p>
<p>创建一个uniform texel buffer的buffer时usage为VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</p>
<p>下列是可用于uniform texel buffers(not limited)的formats:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VK_FORMAT_R8_UNORM, VK_FORMAT_R8_SNORM, VK_FORMAT_R8_UINT, <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R8_SINT</span><br><span class="line">VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SNORM, VK_FORMAT_R8G8_UINT,</span><br><span class="line"><span class="keyword">and</span> VK_FORMAT_R8G8_SINT</span><br><span class="line">VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SNORM,</span><br><span class="line">VK_FORMAT_R8G8B8A8_UINT, <span class="keyword">and</span> VK_FORMAT_R8G8B8A8_SINT</span><br><span class="line">VK_FORMAT_B8G8R8A8_UNORM</span><br><span class="line">VK_FORMAT_A8B8G8R8_UNORM_PACK32, VK_FORMAT_A8B8G8R8_SNORM_PACK32,</span><br><span class="line">VK_FORMAT_A8B8G8R8_UINT_PACK32, <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_A8B8G8R8_SINT_PACK32</span><br><span class="line">VK_FORMAT_A2B10G10R10_UNORM_PACK32 <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_A2B10G10R10_UINT_PACK32</span><br><span class="line">VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT <span class="keyword">and</span> VK_FORMAT_R16_SFLOAT</span><br><span class="line">VK_FORMAT_R16G16_UINT, VK_FORMAT_R16G16_SINT <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R16G16_SFLOAT</span><br><span class="line">VK_FORMAT_R16G16B16A16_UINT, VK_FORMAT_R16G16B16A16_SINT <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R16G16B16A16_SFLOAT</span><br><span class="line">VK_FORMAT_R32_UINT, VK_FORMAT_R32_SINT <span class="keyword">and</span> VK_FORMAT_R32_SFLOAT</span><br><span class="line">VK_FORMAT_R32G32_UINT, VK_FORMAT_R32G32_SINT <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R32G32_SFLOAT</span><br><span class="line">VK_FORMAT_R32G32B32A32_UINT, VK_FORMAT_R32G32B32A32_SINT <span class="keyword">and</span></span><br><span class="line">VK_FORMAT_R32G32B32A32_SFLOAT</span><br><span class="line">VK_FORMAT_B10G11R11_UFLOAT_PACK32</span><br></pre></td></tr></table></figure>
<p>检查是否支持</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkFormatProperties format_properties;</span><br><span class="line">vkGetPhysicalDeviceFormatProperties( physical_device, format,</span><br><span class="line">&amp;format_properties );</span><br><span class="line"><span class="keyword">if</span>( !(format_properties.bufferFeatures &amp;</span><br><span class="line">VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Provided format is not supported for a uniform texel</span></span><br><span class="line"><span class="string">buffer."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后create a buffer,memory object and bind it to the buffer,create a buffer view:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateBuffer( logical_device, size, usage |</span><br><span class="line">VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, uniform_texel_buffer ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device,</span><br><span class="line">uniform_texel_buffer, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object )</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !CreateBufferView( logical_device, uniform_texel_buffer, format, <span class="number">0</span>,</span><br><span class="line">VK_WHOLE_SIZE, uniform_texel_buffer_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>uniform texel buffers,我们需要指明data format,以便shaders按照合适的方式访问buffer的内容,这就是buffer view的作用.</p>
<p>GLSL</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (set=m, <span class="keyword">binding</span>=n) <span class="keyword">uniform</span> <span class="type">samplerBuffer</span> &lt;variable name&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="create-a-torage-texel-buffer"><a href="#create-a-torage-texel-buffer" class="headerlink" title="create a torage texel buffer"></a>create a torage texel buffer</h3><p>如果想在shader中存数据到buffer里,需要使用storage buffers,usage为VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</p>
<p>descriptor types:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 或者VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</p>
<p>storage buffers需要注意对齐问题,遵循GLSL的std430是最简单的方式.基本的对齐方式与Uniform buffer的数组和结构体差不多.它们的偏移量不需要四舍五入到16的倍数.规则如下:</p>
<blockquote>
<ul>
<li><p>A scalar variable of size N must be placed at offsets that are a multiple of N</p>
</li>
<li><p>A vector with two components, where each component has a size of N, must be</p>
<p>placed at offsets that are a multiple of 2N</p>
</li>
<li><p>A vector with three or four components, where each component has a size of N,</p>
<p>must be placed at offsets that are a multiple of 4N</p>
</li>
<li><p>An array with elements of size N must be placed at offsets that are a multiple of N</p>
</li>
<li><p>A structure must be placed at offsets that are a multiple of the biggest offset of</p>
</li>
<li><p>any of its members (a member with the biggest offset requirement)</p>
</li>
<li><p>A row-major matrix must be placed at an offset equal to the offset of a vector</p>
<p>with the number of components equal to the number of columns in the matrix</p>
</li>
<li><p>A column-major matrix must be placed at the same offsets as its columns</p>
</li>
</ul>
</blockquote>
<p>dynamic storage buffers不同之处为它们的base memory offset被定义了.在描述符集更新期间为普通存储缓冲区指定的偏移量和范围在下一次更新之前保持不变.在动态变化的情况下,指定的偏移量将变为基址,随后由描述符集绑定到命令缓冲区时指定的动态偏移量修改.</p>
<p>GLSL中使用关键词buffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">layout (set=m, binding=n) buffer &lt;variable name&gt;</span><br><span class="line">&#123;</span><br><span class="line">vec4 &lt;member 1 name&gt;;</span><br><span class="line">mat4 &lt;member 2 name&gt;;</span><br><span class="line">// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个非常关键的信息没有说，关于对齐的计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> minUboAlignment = device-&gt;properties.limits.minUniformBufferOffsetAlignment;</span><br><span class="line">dynamicAlignment = <span class="keyword">sizeof</span> (customstruct);</span><br><span class="line"><span class="keyword">if</span> (minUboAlignment &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dynamicAlignment = (dynamicAlignment + <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(minUboAlignment - <span class="number">1</span>)) &amp; ~(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(minUboAlignment - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> bufferSize = count * dynamicAlignment;</span><br><span class="line">ptr = (customstruct*)tl::alignedAlloc (bufferSize, dynamicAlignment);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"minUniformBufferOffsetAlignment = "</span> &lt;&lt; minUboAlignment &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"dynamicAlignment = "</span> &lt;&lt; dynamicAlignment &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="create-an-input-attachment"><a href="#create-an-input-attachment" class="headerlink" title="create an input attachment"></a>create an input attachment</h3><p>attachment是render passes中dc绘制的RT.</p>
<p>对于input attachments,通常为color或depth/stencil attachments,也可能是其他images.</p>
<p>usage:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</p>
<p> descriptors type:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</p>
<p>vulkan里render passes有一个及以上的subpass,在一个subpass写了attachment,后面的subpass可以读.也是唯一在shaders里读取attachments的方式.</p>
<p>当从input attachments读取数据时,我们仅限于与processed fragment的location对应的location.但这种方法可能比渲染到attachments中、结束render pass、将image绑定到作为sampled image(texture)的descriptor set以及启动另一个不将给定image用作其任何attachments的render pass更为理想.</p>
<p>对于Input attachments,也能用其他images(不必作为color or depth/stencil attachments).只需要使用usage VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT和合适的格式创建.下列格式是强制支持的input attachment(color).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">VK_FORMAT_R5G6B5_UNORM_PACK16</span><br><span class="line">VK_FORMAT_A1R5G5B5_UNORM_PACK16</span><br><span class="line">VK_FORMAT_R8_UNORM, VK_FORMAT_R8_UINT and VK_FORMAT_R8_SINT</span><br><span class="line">VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_UINT, and VK_FORMAT_R8G8_SINT</span><br><span class="line">VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_UINT,</span><br><span class="line">VK_FORMAT_R8G8B8A8_SINT, and VK_FORMAT_R8G8B8A8_SRGB</span><br><span class="line">VK_FORMAT_B8G8R8A8_UNORM and VK_FORMAT_B8G8R8A8_SRGB</span><br><span class="line">VK_FORMAT_A8B8G8R8_UNORM_PACK32, VK_FORMAT_A8B8G8R8_UINT_PACK32,</span><br><span class="line">VK_FORMAT_A8B8G8R8_SINT_PACK32, and</span><br><span class="line">VK_FORMAT_A8B8G8R8_SRGB_PACK32</span><br><span class="line">VK_FORMAT_A2B10G10R10_UNORM_PACK32 and</span><br><span class="line">VK_FORMAT_A2B10G10R10_UINT_PACK32</span><br><span class="line">VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT and VK_FORMAT_R16_SFLOAT</span><br><span class="line">VK_FORMAT_R16G16_UINT, VK_FORMAT_R16G16_SINT and</span><br><span class="line">VK_FORMAT_R16G16_SFLOAT</span><br><span class="line">VK_FORMAT_R16G16B16A16_UINT, VK_FORMAT_R16G16B16A16_SINT, and</span><br><span class="line">VK_FORMAT_R16G16B16A16_SFLOAT</span><br><span class="line">VK_FORMAT_R32_UINT, VK_FORMAT_R32_SINT, and VK_FORMAT_R32_SFLOAT</span><br><span class="line">VK_FORMAT_R32G32_UINT, VK_FORMAT_R32G32_SINT, and</span><br><span class="line">VK_FORMAT_R32G32_SFLOAT</span><br><span class="line">VK_FORMAT_R32G32B32A32_UINT, VK_FORMAT_R32G32B32A32_SINT, and</span><br><span class="line">VK_FORMAT_R32G32B32A32_SFLOAT</span><br></pre></td></tr></table></figure>
<p>depth/stencil 强制支持的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VK_FORMAT_D16_UNORM</span><br><span class="line">VK_FORMAT_X8_D24_UNORM_PACK32 or VK_FORMAT_D32_SFLOAT (at least one of</span><br><span class="line">these two formats must be supported)</span><br><span class="line">VK_FORMAT_D24_UNORM_S8_UINT or VK_FORMAT_D32_SFLOAT_S8_UINT (at</span><br><span class="line">least one of these two formats must be supported)</span><br></pre></td></tr></table></figure>
<p>其他格式需要检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">VkFormatProperties format_properties;</span><br><span class="line">vkGetPhysicalDeviceFormatProperties( physical_device, format,</span><br><span class="line">&amp;format_properties );</span><br><span class="line"><span class="keyword">if</span>( (aspect &amp; VK_IMAGE_ASPECT_COLOR_BIT) &amp;&amp;</span><br><span class="line">!(format_properties.optimalTilingFeatures &amp;</span><br><span class="line">VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Provided format is not supported for an input attachment."</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (aspect &amp; (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_DEPTH_BIT)) &amp;&amp;</span><br><span class="line">!(format_properties.optimalTilingFeatures &amp;</span><br><span class="line">VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) ) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Provided format is not supported for an input attachment."</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建image,allocate a memory object(或使用已有的),bind it to the image,create an image view.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateImage( logical_device, type, format, size, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">VK_SAMPLE_COUNT_1_BIT, usage | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, <span class="literal">false</span>,</span><br><span class="line">input_attachment ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device,</span><br><span class="line">input_attachment, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !CreateImageView( logical_device, input_attachment, view_type, format,</span><br><span class="line">aspect, input_attachment_image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>需要准备合适的render pass的descrition,包括framebuffers的image views.</p>
<p>GLSL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout (input_attachment_index=i, <span class="built_in">set</span>=m, binding=n) uniform subpassInput</span><br><span class="line">&lt;variable name&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a>descriptor</h2><h3 id="create-a-descriptor-set-layout"><a href="#create-a-descriptor-set-layout" class="headerlink" title="create a descriptor set layout"></a>create a descriptor set layout</h3><p>descritor sets将很多resources(descriptors)收集到一个object里.之后再pipeline中建立了app和shaders的接口.但是硬件要知道什么资源组织在set里,每种有多少,什么顺序,我们需要创建descriptor set layout.</p>
<p>descriptor set layout指明了descriptor set的核心结构,同时,严格定义了什么资源能被它bound.</p>
<p>当创建layout需要知道什么资源(descriptor types)会被用以及他们的顺序.顺序是通过bindings指明的.shader里的index.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (set=m, binding=n) // variable definition</span><br></pre></td></tr></table></figure>
<p>西安志明所有资源的列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkDescriptorSetLayoutCreateInfo descriptor_set_layout_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(bindings.size()),</span><br><span class="line">    bindings.data()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>create layout</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkCreateDescriptorSetLayout( logical_device,</span><br><span class="line">&amp;descriptor_set_layout_create_info, <span class="literal">nullptr</span>, &amp;descriptor_set_layout );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create a layout for descriptor sets."</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>descriptor set layouts也form了一个个pipeline layout,定义了已给pipeline能访问的resources type.created layouts是创建pipeline layout的一部分也是descriptor set allocation要求的.</p>
<h3 id="createa-a-descriptor-pool"><a href="#createa-a-descriptor-pool" class="headerlink" title="createa a descriptor pool"></a>createa a descriptor pool</h3><p>descriptors由descriptor pools分配.创建descriptor pools时需要指明什么descriptors,多少，能从该pool创建.</p>
<p>VkDescriptorPoolCreateInfo</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkDescriptorPoolCreateInfo descriptor_pool_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    free_individual_sets ?</span><br><span class="line"></span><br><span class="line">    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT : <span class="number">0</span>,</span><br><span class="line">    max_sets_count,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(descriptor_types.size()),</span><br><span class="line">    descriptor_types.data()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意多线程问题.</p>
<h3 id="allocating-descriptor-sets"><a href="#allocating-descriptor-sets" class="headerlink" title="allocating descriptor sets"></a>allocating descriptor sets</h3><p>Descriptor sets汇集shader resources(descriptors)到一个object容器里.它的内容，types,资源数量由descritpor set layout定义.storage 从池里取,</p>
<p>descriptor sets提供了shaders的resources.他们形成了app和programmable pipeline stages的interface.这个interface的结构由descriptor set layouts定义.当使用image或buffer resources更新descriptor sets时提供了真实数据,然后在recording 操作绑定descriptor sets到cb.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkDescriptorSetAllocateInfo descriptor_set_allocate_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    descriptor_pool,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(descriptor_set_layouts.size()),</span><br><span class="line">    descriptor_set_layouts.data()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后,allocate descriptor sets</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">descriptor_sets.resize( descriptor_set_layouts.size() );</span><br><span class="line">VkResult result = vkAllocateDescriptorSets( logical_device,</span><br><span class="line">&amp;descriptor_set_allocate_info, descriptor_sets.data() );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not allocate descriptor sets."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>不幸的是,当我们分配和释放separate descriptor sets时,池的内存可能会变得fragmented(支离破碎).此时即使还没到上限也不能申请新的sets了.如下</p>
<p><img src="media/descriptorsetspool.png" alt></p>
<p>第一次allocate descriptors sets,fragmentation问题不会发生</p>
<p>另外,如果每个descritor sets使用相同类型相同数量的资源也不会产生这个问题.</p>
<p>为了避免这个问题,需要释放一次释放所有descriptor sets,否则,只能创建一个新的pool.</p>
<h3 id="updating-descriptor-sets"><a href="#updating-descriptor-sets" class="headerlink" title="updating descriptor sets"></a>updating descriptor sets</h3><p>现在想提供特定的资源(samplers,image views,buffers,buffer views)(之后通过descriptor sets绑定到pipeline).定义应该使用的资源是通过update descriptor sets的过程来完成的.</p>
<p>一些自定义结构</p>
<p>samplers</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageDescriptorInfo</span> &#123;</span></span><br><span class="line">    VkDescriptorSet TargetDescriptorSet;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetDescriptorBinding;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetArrayElement;</span><br><span class="line">    VkDescriptorType TargetDescriptorType;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkDescriptorImageInfo&gt; ImageInfos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>uniform 和 storage buffers</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferDescriptorInfo</span> &#123;</span></span><br><span class="line">    VkDescriptorSet TargetDescriptorSet;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetDescriptorBinding;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetArrayElement;</span><br><span class="line">    VkDescriptorType TargetDescriptorType;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkDescriptorBufferInfo&gt; BufferInfos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>uniform and storage texel buffer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TexelBufferDescriptorInfo</span> &#123;</span></span><br><span class="line">    VkDescriptorSet TargetDescriptorSet;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetDescriptorBinding;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetArrayElement;</span><br><span class="line">    VkDescriptorType TargetDescriptorType;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkBufferView&gt; TexelBufferViews;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以从另一个descriptor拷贝.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CopyDescriptorInfo</span> &#123;</span></span><br><span class="line">    VkDescriptorSet TargetDescriptorSet;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetDescriptorBinding;</span><br><span class="line">    <span class="keyword">uint32_t</span> TargetArrayElement;</span><br><span class="line">    VkDescriptorSet SourceDescriptorSet;</span><br><span class="line">    <span class="keyword">uint32_t</span> SourceDescriptorBinding;</span><br><span class="line">    <span class="keyword">uint32_t</span> SourceArrayElement;</span><br><span class="line">    <span class="keyword">uint32_t</span> DescriptorCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前面所有的结构都定义了应该更新的descriptor set的句柄、给定集内描述符的索引以及数组中的索引如果要更新的话.通过数组访问的描述符.其余参数是特定于类型的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkWriteDescriptorSet&gt; write_descriptors;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; image_descriptor : image_descriptor_infos ) &#123;</span><br><span class="line">    write_descriptors.push_back( &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    image_descriptor.TargetDescriptorSet,</span><br><span class="line">    image_descriptor.TargetDescriptorBinding,</span><br><span class="line">    image_descriptor.TargetArrayElement,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(image_descriptor.ImageInfos.size()),</span><br><span class="line">    image_descriptor.TargetDescriptorType,</span><br><span class="line">    image_descriptor.ImageInfos.data(),</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span></span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; buffer_descriptor : buffer_descriptor_infos ) &#123;</span><br><span class="line">    write_descriptors.push_back( &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    buffer_descriptor.TargetDescriptorSet,</span><br><span class="line">    buffer_descriptor.TargetDescriptorBinding,</span><br><span class="line">    buffer_descriptor.TargetArrayElement,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(buffer_descriptor.BufferInfos.size()),</span><br><span class="line">    buffer_descriptor.TargetDescriptorType,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    buffer_descriptor.BufferInfos.data(),</span><br><span class="line">    <span class="literal">nullptr</span></span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; texel_buffer_descriptor : texel_buffer_descriptor_infos ) &#123;</span><br><span class="line">    write_descriptors.push_back( &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    texel_buffer_descriptor.TargetDescriptorSet,</span><br><span class="line">    texel_buffer_descriptor.TargetDescriptorBinding,</span><br><span class="line">    texel_buffer_descriptor.TargetArrayElement,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(texel_buffer_descriptor.TexelBufferViews.size()),</span><br><span class="line">    texel_buffer_descriptor.TargetDescriptorType,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    texel_buffer_descriptor.TexelBufferViews.data()</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也能复用其他sets的descriptor,更快.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;VkCopyDescriptorSet&gt; copy_descriptors;</span><br><span class="line">for( auto &amp; copy_descriptor : copy_descriptor_infos ) &#123;</span><br><span class="line">    copy_descriptors.push_back( &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,</span><br><span class="line">    nullptr,</span><br><span class="line">    copy_descriptor.SourceDescriptorSet,</span><br><span class="line">    copy_descriptor.SourceDescriptorBinding,</span><br><span class="line">    copy_descriptor.SourceArrayElement,</span><br><span class="line">    copy_descriptor.TargetDescriptorSet,</span><br><span class="line">    copy_descriptor.TargetDescriptorBinding,</span><br><span class="line">    copy_descriptor.TargetArrayElement,</span><br><span class="line">    copy_descriptor.DescriptorCount</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update descriptor sets</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vkUpdateDescriptorSets( logical_device,</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(write_descriptors.size()), write_descriptors.data(),</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(copy_descriptors.size()), copy_descriptors.data() );</span><br></pre></td></tr></table></figure>
<h3 id="binding-descriptor-sets"><a href="#binding-descriptor-sets" class="headerlink" title="binding descriptor sets"></a>binding descriptor sets</h3><p>创建好descriptor set后,需要在recording 操作中将之绑定到cb.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBuffer command_buffer;</span><br><span class="line">VkPipelineLayout pipeline_layout;</span><br><span class="line">td::<span class="built_in">vector</span>&lt;VkDescriptorSet&gt; descriptor_sets;</span><br><span class="line"><span class="keyword">uint32_t</span> index_for_first_set;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; dynamic_offsets;</span><br><span class="line">vkCmdBindDescriptorSets( command_buffer, pipeline_type,</span><br><span class="line">pipeline_layout, index_for_first_set, <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;</span><br><span class="line">(descriptor_sets.size()), descriptor_sets.data(),</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(dynamic_offsets.size()),</span><br><span class="line">dynamic_offsets.data() )</span><br></pre></td></tr></table></figure>
<p>当我们record a command buffer,它的state是未定义的额.在record 与image 或 buffer资源相关的drawing操作前,我们需要给cb绑定合适的resources.通过vkCmdBindDescriptorSets()绑定descriptor sets实现的.</p>
<h3 id="create-descriptors-with-a-texture-and-a-uniform-buffer"><a href="#create-descriptors-with-a-texture-and-a-uniform-buffer" class="headerlink" title="create descriptors with a texture and a uniform buffer"></a>create descriptors with a texture and a uniform buffer</h3><p>创建a combined image sampler和a uniform buffer为descriptors创建做准备</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateCombinedImageSampler( physical_device, logical_device,</span><br><span class="line">VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, sampled_image_size, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">VK_IMAGE_USAGE_TRANSFER_DST_BIT,</span><br><span class="line">VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_ASPECT_COLOR_BIT, VK_FILTER_LINEAR,</span><br><span class="line">VK_FILTER_LINEAR, VK_SAMPLER_MIPMAP_MODE_NEAREST,</span><br><span class="line">VK_SAMPLER_ADDRESS_MODE_REPEAT,</span><br><span class="line">VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_REPEAT, <span class="number">0.0f</span>,</span><br><span class="line"><span class="literal">false</span>, <span class="number">1.0f</span>, <span class="literal">false</span>, VK_COMPARE_OP_ALWAYS, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, <span class="literal">false</span>,</span><br><span class="line">sampler, sampled_image, sampled_image_memory_object, sampled_image_view )</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !CreateUniformBuffer( physical_device, logical_device,</span><br><span class="line">uniform_buffer_size, VK_BUFFER_USAGE_TRANSFER_DST_BIT, uniform_buffer,</span><br><span class="line">uniform_buffer_memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后准备定义descriptor set核心结构的layout</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkDescriptorSetLayoutBinding&gt; bindings = &#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">    <span class="literal">nullptr</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">    <span class="literal">nullptr</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>( !CreateDescriptorSetLayout( logical_device, bindings,</span><br><span class="line">descriptor_set_layout ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组后,用一开始创建的resources更新descriptor set</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageDescriptorInfo&gt; image_descriptor_infos = &#123;</span><br><span class="line">&#123;</span><br><span class="line">    descriptor_sets[<span class="number">0</span>],</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,</span><br><span class="line">    &#123;</span><br><span class="line">   		&#123;</span><br><span class="line">            sampler,</span><br><span class="line">            sampled_image_view,</span><br><span class="line">            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span><br><span class="line">    	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BufferDescriptorInfo&gt; buffer_descriptor_infos = &#123;</span><br><span class="line">&#123;</span><br><span class="line">    descriptor_sets[<span class="number">0</span>],</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                uniform_buffer,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                VK_WHOLE_SIZE</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">UpdateDescriptorSets( logical_device, image_descriptor_infos,</span><br><span class="line">buffer_descriptor_infos, &#123;&#125;, &#123;&#125; );</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h2><h3 id="free-descriptor-sets"><a href="#free-descriptor-sets" class="headerlink" title="free descriptor sets"></a>free descriptor sets</h3><p>如果向将descriptor set的内存归还给pool，可以free它.归还后可以用来创建另一个,但是可能会由于Pool内存的碎片化导致失败.</p>
<p>能够一次释放多个descriptor sets,(来自同一个pool的)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkFreeDescriptorSets( logical_device, descriptor_pool,</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(descriptor_sets.size()), descriptor_sets.data() );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error occurred during freeing descriptor sets."</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">descriptor_sets.clear();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="reset-a-descriptor-pool"><a href="#reset-a-descriptor-pool" class="headerlink" title="reset a descriptor pool"></a>reset a descriptor pool</h3><p>能够一次释放一个pool的所有descriptor sets.</p>
<p>如果pool创建flag没有VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,该方法是唯一释放其descriptor sets的方法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkResetDescriptorPool( logical_device, descriptor_pool, <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error occurred during descriptor pool reset."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="destroy-a-descriptor-pool"><a href="#destroy-a-descriptor-pool" class="headerlink" title="destroy a descriptor pool"></a>destroy a descriptor pool</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != descriptor_pool ) &#123;</span><br><span class="line">    vkDestroyDescriptorPool( logical_device, descriptor_pool, <span class="literal">nullptr</span> );</span><br><span class="line">    descriptor_pool = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="destroy-a-descriptor-set-layout"><a href="#destroy-a-descriptor-set-layout" class="headerlink" title="destroy a descriptor set layout"></a>destroy a descriptor set layout</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != descriptor_set_layout ) &#123;</span><br><span class="line">	vkDestroyDescriptorSetLayout( logical_device, descriptor_set_layout,</span><br><span class="line"><span class="literal">nullptr</span> );</span><br><span class="line">	descriptor_set_layout = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="destroy-a-sampler"><a href="#destroy-a-sampler" class="headerlink" title="destroy a sampler"></a>destroy a sampler</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != sampler ) &#123;</span><br><span class="line">    vkDestroySampler( logical_device, sampler, <span class="literal">nullptr</span> );</span><br><span class="line">    sampler = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://noleafnolife.com/2019/04/05/sdk/graphics/vulkan/4.ResourcesandMemory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nolife">
      <meta itemprop="description" content="一个游戏程序员的blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stoner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/05/sdk/graphics/vulkan/4.ResourcesandMemory/" class="post-title-link" itemprop="url">Resources and Memory</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-05 21:16:00 / Modified: 21:19:35" itemprop="dateCreated datePublished" datetime="2019-04-05T21:16:00+08:00">2019-04-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/" itemprop="url" rel="index"><span itemprop="name">sdk</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/" itemprop="url" rel="index"><span itemprop="name">graphics</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/vulkan/" itemprop="url" rel="index"><span itemprop="name">vulkan</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="Resources-and-Memory"><a href="#Resources-and-Memory" class="headerlink" title="Resources and Memory"></a>Resources and Memory</h1><p>[TOC]</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>Creating a buffer<br>Allocating and binding a memory object for a buffer<br>Setting a buffer memory barrier<br>Creating a buffer view<br>Creating an image<br>Allocating and binding a memory object to an image<br>Setting an image memory barrier<br>Creating an image view<br>Creating a 2D image and view<br>Creating a layered 2D image with a CUBEMAP view<br>Mapping, updating, and unmapping host-visible memory<br>Copying data between buffers<br>Copying data from a buffer to an image<br>Copying data from an image to a buffer<br>Using a staging buffer to update a buffer with a device-local memory bound<br>Using a staging buffer to update an image with a device-local memory bound<br>Destroying an image view<br>Destroying an image<br>Destroying a buffer view<br>Freeing a memory object<br>Destroying a buffer</p>
<p>Vulkan里非常重要的存储数据的资源时buffers和images.buffers存储linear数组数据.Images和OpenGL的textures类似,有1D,2D,3D.Buffers和Images可以用于很多目的:shaders里可以read或者sample数据,或者存储数据.Images可以用于color或者depth/stencil绑定(RT),也就是说可以渲染到其上.Buffer还可以存储顶点数据、indices,parameters(indiret drawing).</p>
<p>重要的是提及的所有usages需要在创建资源时指明(可以一次提供很多).</p>
<p>Vulkan里buffers和images没有自己的storage,需要创建和绑定memory objects.</p>
<p>本节介绍如何使用这些资源、如何申请缓存和绑定、如何上传数据到GPU、如何在资源见进行拷贝.</p>
<h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><h3 id="创建buffer"><a href="#创建buffer" class="headerlink" title="创建buffer"></a>创建buffer</h3><p>buffers能用于很多目的.它们能通过descriptor sets在pipelines中统一uniform buffers、storage buffers、texel buffer等的后备缓冲.它们能作为vertex indices或者attributes的数据源,或者暂存从CPU到GPU移动数据的staging resources.为了这些目的,我们需要创建buffer和指定它的usage.</p>
<p>buffers只能用于创建时指定的usages.</p>
<p>buffers支持的使用方式列表</p>
<table>
<thead>
<tr>
<th>flag</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</td>
<td>specifies that the buffer can be a source of data for copy operations</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_TRANSFER_DST_BIT</td>
<td>specifies that we can copy data to the  buffer</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</td>
<td>indicates that the buffer can be used in shaders as a uniform texel buffer</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</td>
<td>specifies that the buffer can be used in shaders as a storage texel buffer</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</td>
<td>indicates that the buffer can be used in shaders as a source of values for uniform variables</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</td>
<td>indicates that we can store data in the buffer from within shaders</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</td>
<td>specifies that the buffer can be used as a source of vertex indices during drawing</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</td>
<td>indicates that the buffer can be a source of data for vertex attributes specified during drawing</td>
</tr>
<tr>
<td>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</td>
<td>indicates that the buffer can contain data that will be used during indirect drawing</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkBufferCreateInfo buffer_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    size,</span><br><span class="line">    usage,</span><br><span class="line">    VK_SHARING_MODE_EXCLUSIVE,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之前的VK_SHARING_MODE_EXCLUSIVE(sharingMode)是一个非常重要的参数.通过它我们能指定多families里的queues能否同时访问buffer.Exclusive shaing mode(独占)告诉驱动程序缓冲区只能由一个系列中的队列一次引用.如果想从另一个family提交的commands使用buffer,必须在所有者改变时明确告诉驱动(从一个family改为另一个).这样性能更好但也更麻烦.</p>
<p>我们也可以指明VK_SHARING_MODE_CONCURRENT,这样多families多queues能够同时访问一个buffer，并且不用进行所有者转换,但并发性能可能很低.</p>
<p>创建buffer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkCreateBuffer( logical_device, &amp;buffer_create_info,</span><br><span class="line"><span class="literal">nullptr</span>, &amp;buffer );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create a buffer."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="allocating-and-binding-a-memory-object-for-a-buffer"><a href="#allocating-and-binding-a-memory-object-for-a-buffer" class="headerlink" title="allocating and binding a memory object for a buffer"></a>allocating and binding a memory object for a buffer</h3><p>Vulkan里buffers和images没有自己的memroy,需要allocate memory object并绑定.</p>
<p>关于内存管理</p>
<p> <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator" target="_blank" rel="noopener">https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator</a></p>
<p><a href="https://www.youtube.com/watch?v=rXSdDE7NWmA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rXSdDE7NWmA</a></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1.take VkPhysicalDevice physical_device</p>
<p>2.create VkPhysicalDeviceMemoryProperties physical_device_memory_properties</p>
<p>3.clall vkGetPhysicalDeviceMemoryProperties( physical_device,&amp;physical_device_memory_properties )会存储内存相关参数(heaps的数量,大小,types)</p>
<p>4.take VkDevice logical_device</p>
<p>5.take VkBuffer buffer</p>
<p>6.create VkMemoryRequirements memory_requirements.</p>
<p>7.call vkGetBufferMemoryRequirements(logical_device, buffer,&amp;memory_requirements);</p>
<p>8.create VkDeviceMemory memory_object = VK_NULL_HANDLE;</p>
<p>9.create VkMemoryPropertyFlagBits memory_properties</p>
<p>10.遍历physical device的physical_device_memory_properties的内存types,每次循环进行如下操作:</p>
<blockquote>
<p>1.确保memory_requirements.memoryTypeBits 设置了</p>
<p>2.确保memory_properties变量的位设置与memory type的propertyflags成员相同,该成员位于物理_device_memory_properties变量中memorytypes数组的索引类型.</p>
<p>3.如果1、2为false,continue</p>
<p>4.创建VkMemoryAllocateInfo buffer_memory_allocate_info</p>
<p>.allocationSize = memory_requirements.size,</p>
<p>.memoryTypeIndex = type</p>
<p>5.vkAllocateMemory( logical_device,&amp;buffer_memory_allocate_info, nullptr, &amp;memory_object)</p>
<p>6.确认结果为VK_SUCCESS</p>
</blockquote>
<p>11.确保allocate的memory object成功</p>
<p>12.绑定,call vkBindBufferMemory(logical_device, buffer, memory_object, 0 )</p>
<p>13.确保call成功</p>
<p>为了给buffer allocate a memory,需要知道可用的memory types(physical device)以及有多少.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkPhysicalDeviceMemoryProperties physical_device_memory_properties;</span><br><span class="line">vkGetPhysicalDeviceMemoryProperties( physical_device,</span><br><span class="line">&amp;physical_device_memory_properties );</span><br></pre></td></tr></table></figure>
<p>接下来,我们需要知道给定缓冲区需要多少存储(缓冲区的内存可能需要大于缓冲区的大小),以及与之兼容的内存类型.这些信息存储在VkMemoryRequirements:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VkMemoryRequirements memory_requirements;</span><br><span class="line">vkGetBufferMemoryRequirements(logical_device, buffer, &amp;memory_requirements);</span><br></pre></td></tr></table></figure>
<p>接下来,我们需要检查哪个内存类型对应于缓冲区的内存需求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">memory_object = VK_NULL_HANDLE;</span><br><span class="line">for( uint32_t type = 0; type &lt; physical_device_memory_properties.memoryTypeCount; ++type ) </span><br><span class="line">&#123;</span><br><span class="line">    if( (memory_requirements.memoryTypeBits &amp; (1 &lt;&lt; type)) &amp;&amp;</span><br><span class="line">    ((physical_device_memory_properties.memoryTypes[type].propertyFlags &amp;</span><br><span class="line">    memory_properties) == memory_properties) ) </span><br><span class="line">    &#123;</span><br><span class="line">        VkMemoryAllocateInfo buffer_memory_allocate_info = </span><br><span class="line">        &#123;</span><br><span class="line">            VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,</span><br><span class="line">            nullptr,</span><br><span class="line">            memory_requirements.size,</span><br><span class="line">            type</span><br><span class="line">        &#125;;</span><br><span class="line">        VkResult result = vkAllocateMemory( logical_device,</span><br><span class="line">        &amp;buffer_memory_allocate_info, nullptr, &amp;memory_object );</span><br><span class="line">        if( VK_SUCCESS == result ) </span><br><span class="line">        &#123;</span><br><span class="line">      	  break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里遍历所有可用memory types以检查是否能够用于我们的buffer,我们也能检查一些额外的属性,比如如果想直接从CPU上传数据到GPU，memory mapping必须支持.这种情况下,我们需要使用的memory type为host-visible.</p>
<p>当我们找到合适的memory type后,我们能用它allocate memory object并break,然后可以绑定了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE == memory_object ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not allocate memory for a buffer."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">VkResult result = vkBindBufferMemory( logical_device, buffer,</span><br><span class="line">memory_object, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not bind memory object to a buffer."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>绑定时,指定了offset等其他参数.这个参数在内存管理里很有用.</p>
<p>通常来说,不会为每个buffer使用一个分开的memory object.而是allocate很大的memory objects,多个buffers各使用其一部分.在这种方式中,我们通过call vkGetPhysicalDeviceMemoryProperties来获取物理设备的可用内存类型.但通常来说,为了提高app的性能,不会每次需要allocate memory object的时候都调用它.我们只需要调用一次,在我们选择一个physical device后可以使用存储的参数.</p>
<h3 id="set-a-buffer-memory-barrier"><a href="#set-a-buffer-memory-barrier" class="headerlink" title="set a buffer memory barrier"></a>set a buffer memory barrier</h3><p>我们必须通知一个驱动程序每一个这样的使用,不仅在缓冲区创建期间,而且在预期的使用之前.当我们出于一个目的使用缓冲区,并且从现在开始我们想以不同的方式使用它时,我们必须告诉驱动程序缓冲区的使用发生了变化.这是通过缓冲存储器屏障(barrier)实现的.在cb record时,它们作为pipeline barriers的一部分.</p>
<p>自定义一个结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferTransition</span> &#123;</span></span><br><span class="line">    VkBuffer Buffer;</span><br><span class="line">    <span class="comment">//VkAccessFlags buffer如何使用</span></span><br><span class="line">    VkAccessFlags CurrentAccess;</span><br><span class="line">    VkAccessFlags NewAccess;</span><br><span class="line">    <span class="comment">//用于想将buffer用于不同families的queue时(exclusive sharing mode时用到)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> CurrentQueueFamily;</span><br><span class="line">    <span class="keyword">uint32_t</span> NewQueueFamily;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Vulkan里,提交给queues的opoerations是按顺序执行的,但也是独立的.有时有些操作需要等待其他操作结束后才能执行,这时候memory barriers就有用了.</p>
<p>memory barriers用于定义命令缓冲区执行中的时刻,在这些时刻中,后面的命令应该等待前面的命令完成它们的工作.它们还使这些操作的结果对其他操作可见。</p>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>使用目的</p>
<table>
<thead>
<tr>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</td>
<td>specifies that the image can be used as a source of data for copy operations</td>
</tr>
<tr>
<td>VK_IMAGE_USAGE_TRANSFER_DST_BIT</td>
<td>specifies that we can copy data to the image</td>
</tr>
<tr>
<td>VK_IMAGE_USAGE_SAMPLED_BIT</td>
<td>indicates that we can sample data from the image inside shaders</td>
</tr>
<tr>
<td>VK_IMAGE_USAGE_STORAGE_BIT</td>
<td>specifies that the image can be used as a storage image inside shaders</td>
</tr>
<tr>
<td>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</td>
<td>specifies that we can render into an image (use it as a color render target/attachment in a framebuffer)</td>
</tr>
<tr>
<td>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</td>
<td>indicates that the image can be used as a depth and/or stencil buffer (as a depth render target/attachment</td>
</tr>
</tbody>
</table>
<p>in a framebuffer) |<br>| VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT     | indicates that the memory bound to the image will be allocated lazily (on demand) |<br>| VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT         | specifies that the image can be used as an input attachment inside shaders |</p>
<p> 不同的usage情景要求使用不同的image layout,通过使用image memory barriers进行改变,我们需需要指明VK_IMAGE_LAYOUT_UNDEFINED,如果不在意初始化内容,或者VK_IMAGE_LAYOUT_PREINITIALIZED如果想通过mapping host-visible memory上传数据.在使用前总需要transition to another layout.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">VkImageCreateInfo image_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    cubemap ? VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT : <span class="number">0u</span>,</span><br><span class="line">    type,</span><br><span class="line">    format,</span><br><span class="line">    size,</span><br><span class="line">    num_mipmaps,</span><br><span class="line">    cubemap ? <span class="number">6</span> * num_layers : num_layers,</span><br><span class="line">    samples,</span><br><span class="line">    VK_IMAGE_TILING_OPTIMAL,</span><br><span class="line">    usage_scenarios,</span><br><span class="line">    VK_SHARING_MODE_EXCLUSIVE,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    VK_IMAGE_LAYOUT_UNDEFINED</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建Image时需要指明tiling</p>
<blockquote>
<ul>
<li>linear tiling:在memory中线性存储,这允许我们映射图像的内存并直接从应用程序读取或初始化它,因为我们知道内存是如何组织的.但对使用目的有严格显示,比如不能作为depth texture或cubemap.会降低性能</li>
<li>optimal tiling:能用于所有目的,性能更好,作为代价不知道image得memory如何组织.</li>
</ul>
</blockquote>
<p><img src="media/imageoptionaltiling.png" alt></p>
<p>不同硬件存储image数据方式不同.所以不能在app中直接mapping、初始化、读image的内存.此时,可以使用staging resources.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkCreateImage( logical_device, &amp;image_create_info,</span><br><span class="line"><span class="literal">nullptr</span>, &amp;image );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create an image."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="allocating-and-binding-a-memory-object-to-an-image"><a href="#allocating-and-binding-a-memory-object-to-an-image" class="headerlink" title="allocating and binding a memory object to an image"></a>allocating and binding a memory object to an image</h3><p>vkGetImageMemoryRequirements</p>
<p>vkBindImageMemory</p>
<p>先检查可用的memory types.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkPhysicalDeviceMemoryProperties physical_device_memory_properties;</span><br><span class="line">vkGetPhysicalDeviceMemoryProperties( physical_device,</span><br><span class="line">&amp;physical_device_memory_properties );</span><br></pre></td></tr></table></figure>
<p>然后给image请求指定的memory requirememts.每个image可能不同,与format,size,mipmaps和layers的数量和其他属性有关.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VkMemoryRequirements memory_requirements;</span><br><span class="line">vkGetImageMemoryRequirements( logical_device, image, &amp;memory_requirements);</span><br></pre></td></tr></table></figure>
<p>下一步是找到与image的memory requirements适配的memory type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">memory_object = VK_NULL_HANDLE;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">uint32_t</span> type = <span class="number">0</span>; type &lt;physical_device_memory_properties.memoryTypeCount; ++type ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( (memory_requirements.memoryTypeBits &amp; (<span class="number">1</span> &lt;&lt; type)) &amp;&amp;</span><br><span class="line">    ((physical_device_memory_properties.memoryTypes[type].propertyFlags &amp;</span><br><span class="line">    memory_properties) == memory_properties) ) &#123;</span><br><span class="line">        VkMemoryAllocateInfo image_memory_allocate_info = &#123;</span><br><span class="line">        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        memory_requirements.size,</span><br><span class="line">        type</span><br><span class="line">    &#125;;</span><br><span class="line">    VkResult result = vkAllocateMemory( logical_device,</span><br><span class="line">    &amp;image_memory_allocate_info, <span class="literal">nullptr</span>, &amp;memory_object );</span><br><span class="line">    <span class="keyword">if</span>( VK_SUCCESS == result ) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE == memory_object ) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not allocate memory for an image."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">VkResult result = vkBindImageMemory( logical_device, image, memory_object,</span><br><span class="line"><span class="number">0</span> );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not bind memory object to an image."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>申请大内存共享,可以提高性能,可以减少memory浪费.</p>
<h3 id="setting-an-image-memory-barrier"><a href="#setting-an-image-memory-barrier" class="headerlink" title="setting an image memory barrier"></a>setting an image memory barrier</h3><p>image 用于texture,RT(通过descriptor sets),swapchain的images.拷贝(目标或源)</p>
<p>定义一个结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageTransition</span> &#123;</span></span><br><span class="line">    VkImage Image;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    VkAccessFlags CurrentAccess;</span><br><span class="line">    VkAccessFlags NewAccess;</span><br><span class="line">    <span class="comment">//不用image usages有不用的layout,所以改变目的时需要确保</span></span><br><span class="line">    VkImageLayout CurrentLayout;</span><br><span class="line">    VkImageLayout NewLayout;</span><br><span class="line">    <span class="keyword">uint32_t</span> CurrentQueueFamily;</span><br><span class="line">    <span class="keyword">uint32_t</span> NewQueueFamily;</span><br><span class="line">    VkImageAspectFlags Aspect;<span class="comment">//usage.color,depth,stencil</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在我们不想改变ownerships时我们能使用VK_QUEUE_FAMILY_IGNORED.</p>
<p>内存屏障用于定义命令缓冲区执行中的时刻,在这些时刻中,后面的命令应该等待前面的命令完成其任务.它们还使这些操作的结果对其他操作可见.</p>
<p>Barriers用于让后续commands 的memory操作可见</p>
<p><img src="media/imagebarrier.png" alt></p>
<p>为了性能,最好给特定的usages用image memory layout,尽管需要注意频繁转换用处的layout.</p>
<p>VkImageMemoryBarrier</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkImageMemoryBarrier&gt; image_memory_barriers;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; image_transition : image_transitions ) &#123;</span><br><span class="line">    image_memory_barriers.push_back( &#123;</span><br><span class="line">        VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        image_transition.CurrentAccess,</span><br><span class="line">        image_transition.NewAccess,</span><br><span class="line">        image_transition.CurrentLayout,</span><br><span class="line">        image_transition.NewLayout,</span><br><span class="line">        image_transition.CurrentQueueFamily,</span><br><span class="line">        image_transition.NewQueueFamily,</span><br><span class="line">        image_transition.Image,</span><br><span class="line">        &#123;</span><br><span class="line">        image_transition.Aspect,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_REMAINING_MIP_LEVELS,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_REMAINING_ARRAY_LAYERS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要定义pipeline stages</p>
<p><img src="media/imagepipelinestages.png" alt></p>
<p>左侧vertex等待fragment结束</p>
<p>右侧fragment等待vertex结束,减少barrier数量很重要,如果需要以正确设置绘图命令并为屏障选择适当的pipeline stages</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( image_memory_barriers.size() &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    vkCmdPipelineBarrier( command_buffer, generating_stages,</span><br><span class="line">    consuming_stages, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(image_memory_barriers.size()),</span><br><span class="line">    &amp;image_memory_barriers[<span class="number">0</span>] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多次使用于同样的目的,不需要重复设置barrier.这个设置是在改变时设置,而非usage.</p>
<h3 id="create-an-image-view"><a href="#create-an-image-view" class="headerlink" title="create an image view"></a>create an image view</h3><p>Images在Vulkan Commands中被直接使用,Framebuffer和shaders(通过descriptor sets)通过image views访问images.Images view定义了image的内存的选定部分和指明了读取image数据的额外的信息.</p>
<p>VkImageViewCreateInfo<br>VkImageView</p>
<p>image view定义了用于访问image的额外的数据,通过它我们能指明commands能够访问的image的部分.比如,如果渲染到image,可以指明就一个mipmap level需要更新.</p>
<p>Image view也定义了image内存如何解释.一个好的例子是multiple layers.对于它,我们可以定义一个image view来解释image,作为一个layered image,或者我们可以使用image view从中创建一个cubemap映射。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">VkImageViewCreateInfo image_view_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    image,</span><br><span class="line">    view_type,</span><br><span class="line">    format,</span><br><span class="line">    &#123;</span><br><span class="line">        VK_COMPONENT_SWIZZLE_IDENTITY,</span><br><span class="line">        VK_COMPONENT_SWIZZLE_IDENTITY,</span><br><span class="line">        VK_COMPONENT_SWIZZLE_IDENTITY,</span><br><span class="line">        VK_COMPONENT_SWIZZLE_IDENTITY</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        aspect,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_REMAINING_MIP_LEVELS,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_REMAINING_ARRAY_LAYERS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>vkCreateImageView</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkCreateImageView( logical_device,</span><br><span class="line">&amp;image_view_create_info, <span class="literal">nullptr</span>, &amp;image_view );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create an image view."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="create-a-2D-image-and-view"><a href="#create-a-2D-image-and-view" class="headerlink" title="create a 2D image and view"></a>create a 2D image and view</h3><p>RGBA 32bits 2D texture最常用.</p>
<p>分三步</p>
<blockquote>
<ul>
<li>创建一个image</li>
<li>创建一个memory object(或者使用以存在的)绑定到image</li>
<li>创建一个image view</li>
</ul>
</blockquote>
<p>需要创建type为 VK_IMAGE_TYPE_2D,format为VK_FORMAT_R8G8B8A8_UNORM的image.其他image的属性依赖于image的size(换句话说,我们从一个已经存在的image文件创建一个textur,需要匹配它的dimensions)、filtering类型(如果想用mipmapping的话)、samples的数量(如果需要multisampled的话)、期望的usage.</p>
<p>将image创建过程封装在CreateImage里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateImage( logical_device, VK_IMAGE_TYPE_2D, format, &#123; size.width,</span><br><span class="line">size.height, <span class="number">1</span> &#125;, num_mipmaps, num_layers, samples, usage, <span class="literal">false</span>, image ) )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将allocate和bind一个memory object封装在AllocateAndBindMemoryObjectToImage</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device,</span><br><span class="line">image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也能使用一个已经创建的memory</p>
<p>然后创建image view.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateImageView( logical_device, image, VK_IMAGE_VIEW_TYPE_2D, format,</span><br><span class="line">aspect, image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create-a-layered-2D-image-with-a-CUEMAP-view"><a href="#create-a-layered-2D-image-with-a-CUEMAP-view" class="headerlink" title="create a layered 2D image with a CUEMAP view"></a>create a layered 2D image with a CUEMAP view</h3><p>app常用于模拟物体反射环境的CUBEMAPs,不需要创建一个CUBEMAP image,只需要创建一个layered image和通过image view告诉硬件将之视为6个CUBEMAP表面.</p>
<p>与创建普通image一样,不同之处是CUBEMAP需要6个layres,同时不能每个texel不能使用超过一个sample.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateImage( logical_device, VK_IMAGE_TYPE_2D,</span><br><span class="line">    VK_FORMAT_R8G8B8A8_UNORM, &#123; size, size, <span class="number">1</span> &#125;, num_mipmaps, <span class="number">6</span>,</span><br><span class="line">    VK_SAMPLE_COUNT_1_BIT, usage, <span class="literal">true</span>, image ) ) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allocate和bind a memory object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device,</span><br><span class="line">image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建image view,指明CUBEMAP view type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreateImageView( logical_device, image, VK_IMAGE_VIEW_TYPE_CUBE,</span><br><span class="line">VK_FORMAT_R8G8B8A8_UNORM, aspect, image_view ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>faces order +X,-X,+Y,-Y,+Z,-Z</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><h3 id="mapping-updating-and-unmapping-host-visible-memory"><a href="#mapping-updating-and-unmapping-host-visible-memory" class="headerlink" title="mapping,updating and unmapping host-visible memory"></a>mapping,updating and unmapping host-visible memory</h3><p> images和buffers绑定的memory位于显卡硬件(device-local memory),高性能,但不能直接使用,我们需要使用中间的(staging)资源作为GPU(device)-CPU(host)中转.</p>
<p>staging resources需要host-visible,为了上传数据或者读取数据,需要map it.</p>
<p>mapping memory是最简单的用于upload data的方式.需要指明需要map的memory的内容(offset,size).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VkResult result;</span><br><span class="line"><span class="keyword">void</span> * local_pointer;</span><br><span class="line">result = vkMapMemory( logical_device, memory_object, offset, data_size, <span class="number">0</span>,</span><br><span class="line">&amp;local_pointer );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not map memory object."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapping给我们一个指针,与标准c++一样使用,不限制是读还是写.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">memcpy</span>( local_pointer, data, data_size );</span><br></pre></td></tr></table></figure>
<p>当更新了mapped memory range.需要告诉驱动,内存的内容被修改了否则更新的数据不会立刻被其他提交给queues的操作访问.这个过程称为flush.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkMappedMemoryRange&gt; memory_ranges = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    memory_object,</span><br><span class="line">    offset,</span><br><span class="line">    data_size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vkFlushMappedMemoryRanges( logical_device,</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(memory_ranges.size()), &amp;memory_ranges[<span class="number">0</span>] );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not flush mapped memory."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用完映射的memory后,可以unmap.memory mapping不会影响app运行效率.但关闭程序前必须unmap.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( unmap ) &#123;</span><br><span class="line">	vkUnmapMemory( logical_device, memory_object );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>( <span class="literal">nullptr</span> != pointer ) &#123;</span><br><span class="line">	*pointer = local_pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="copy-data-between-buffers"><a href="#copy-data-between-buffers" class="headerlink" title="copy data between buffers"></a>copy data between buffers</h3><p>除了mapping,vulkan还支持memory间(包括不同types)进行内存拷贝.</p>
<p>这类操作需要在command buffer中record.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( regions.size() &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    vkCmdCopyBuffer( command_buffer, source_buffer, destination_buffer,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(regions.size()), &amp;regions[<span class="number">0</span>] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了最好的性能,渲染阶段用到的资源,需要绑定device-local memory.但我们不能map这类memory.使用vkCmdCopyBuffer,能拷贝数据到另一个host-visible内存.这种memory能直接被app给mapped和updated.</p>
<p>能被拷贝的memory创建时要有VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage.<br>能拷贝数据的memory创建时需要有VK_BUFFER_USAGE_TRANSFER_DST_BIT usage.</p>
<p>当想拷贝buffer到另一个buffer,我们需要设置一个memory barrier,告诉硬件从现在开始该buffer的操作需要按照VK_ACCESS_TRANSFER_WRITE_BIT来.当拷贝完后,我们想将之用于特定目的,需要设置另一个memory barrier.</p>
<h3 id="copy-data-from-a-buffer-to-an-image"><a href="#copy-data-from-a-buffer-to-an-image" class="headerlink" title="copy data from a buffer to an image"></a>copy data from a buffer to an image</h3><p>对于images,能帮到不同memory types的memory objects.但只有host-visible memory能被app直接mapped或updated.当想更新一个device-local memory的image需要从一个buffer进行拷贝.</p>
<p>拷贝buffer的数据到image通过comman buffer完成.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( regions.size() &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    vkCmdCopyBufferToImage( command_buffer, source_buffer, destination_image,image_layout, <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(regions.size()), &amp;regions[<span class="number">0</span>] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要知道image data是如何组织在buffer里的.包括memory offset,length of  the data row,height of data in a buffer.可以给row length和height设置为0,表明是紧密的数据,并与image的尺寸一致.</p>
<p>image from:VK_BUFFER_USAGE_TRANSFER_SRC_BIT,在transfer之前,image layout需要为VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</p>
<p>buffer to:VK_BUFFER_USAGE_TRANSFER_DST_BIT</p>
<p>在从image拷贝数据前,需要设置一个memory barrier,改变image得layout VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL.内存方位类型变为VK_ACCESS_TRANSFER_READ_BIT.如果拷贝完后要用于其他目的,需要设置另一个barrier..</p>
<h2 id="staging-buffer"><a href="#staging-buffer" class="headerlink" title="staging buffer"></a>staging buffer</h2><h3 id="使用staging-buffer更新device-local-memory"><a href="#使用staging-buffer更新device-local-memory" class="headerlink" title="使用staging buffer更新device-local memory"></a>使用staging buffer更新device-local memory</h3><p>staging resources用于更新not host-visible的memory的内容.这种memory不能mapped.需要一个中间buffer(可以mapped和更新),通过它传输数据.</p>
<p>需要一个能mapped的buffer,可以用池.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkBuffer staging_buffer;</span><br><span class="line"><span class="keyword">if</span>( !CreateBuffer( logical_device, data_size,</span><br><span class="line">VK_BUFFER_USAGE_TRANSFER_SRC_BIT, staging_buffer ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">VkDeviceMemory memory_object;</span><br><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device,</span><br><span class="line">staging_buffer, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后map it和更新内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !MapUpdateAndUnmapHostVisibleMemory( logical_device, memory_object, <span class="number">0</span>,</span><br><span class="line">data_size, data, <span class="literal">true</span>, <span class="literal">nullptr</span> ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始record command buffer.先给目标buffer设置一个memory barrier,改变它的usage为copy操作的target.staging buffer不需要barrier.当我们map和update buffer的memory,它的内容对其他commands也是可见的.因为导尿管我们开始command buffer recording一个隐性的barrier为host写操作而设置了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !BeginCommandBufferRecordingOperation( command_buffer,</span><br><span class="line">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, <span class="literal">nullptr</span> ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SetBufferMemoryBarrier( command_buffer,</span><br><span class="line">destination_buffer_generating_stages, VK_PIPELINE_STAGE_TRANSFER_BIT, &#123; &#123;</span><br><span class="line">destination_buffer, destination_buffer_current_access,</span><br><span class="line">VK_ACCESS_TRANSFER_WRITE_BIT, VK_QUEUE_FAMILY_IGNORED,</span><br><span class="line">VK_QUEUE_FAMILY_IGNORED &#125; &#125; );</span><br></pre></td></tr></table></figure>
<p>然后我们能record拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyDataBetweenBuffers( command_buffer, staging_buffer, destination_buffer,</span><br><span class="line">&#123; &#123; <span class="number">0</span>, destination_offset, data_size &#125; &#125; );</span><br></pre></td></tr></table></figure>
<p>之后,需要为target buffer设置另一个barrier.将他的usage改为使用时期望的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SetBufferMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT,</span><br><span class="line">destination_buffer_consuming_stages, &#123; &#123; destination_buffer,</span><br><span class="line">VK_ACCESS_TRANSFER_WRITE_BIT, destination_buffer_new_access,</span><br><span class="line">VK_QUEUE_FAMILY_IGNORED, VK_QUEUE_FAMILY_IGNORED &#125; &#125; );</span><br><span class="line"><span class="keyword">if</span>( !EndCommandBufferRecordingOperation( command_buffer ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个fence,并在submit cb到queue时使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VkFence fence;</span><br><span class="line"><span class="keyword">if</span>( !CreateFence( logical_device, <span class="literal">false</span>, fence ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !SubmitCommandBuffersToQueue( <span class="built_in">queue</span>, &#123;&#125;, &#123; command_buffer &#125;,</span><br><span class="line">signal_semaphores, fence ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不再想使用staging buffer,销毁它.但必须在使用完成之后才能进行.(fence).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !WaitForFences( logical_device, &#123; fence &#125;, VK_FALSE, <span class="number">500000000</span> ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">DestroyBuffer( logical_device, staging_buffer );</span><br><span class="line">FreeMemoryObject( logical_device, memory_object );</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>真实应用中,通常使用一个池,复用它,而不是动态创建.这样能避免wait fence的时间,也能提高效率</p>
<h3 id="使用staging-buffer更新device-local-memory-image"><a href="#使用staging-buffer更新device-local-memory-image" class="headerlink" title="使用staging buffer更新device-local memory image"></a>使用staging buffer更新device-local memory image</h3><p>与上面的类似.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VkBuffer staging_buffer;</span><br><span class="line"><span class="keyword">if</span>( !CreateBuffer( logical_device, data_size,</span><br><span class="line">VK_BUFFER_USAGE_TRANSFER_SRC_BIT, staging_buffer ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">VkDeviceMemory memory_object;</span><br><span class="line"><span class="keyword">if</span>( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device,</span><br><span class="line">staging_buffer, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, memory_object ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( !MapUpdateAndUnmapHostVisibleMemory( logical_device, memory_object, <span class="number">0</span>,</span><br><span class="line">data_size, data, <span class="literal">true</span>, <span class="literal">nullptr</span> ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置barrier</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !BeginCommandBufferRecordingOperation( command_buffer,</span><br><span class="line">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, <span class="literal">nullptr</span> ) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SetImageMemoryBarrier( command_buffer, destination_image_generating_stages,</span><br><span class="line">VK_PIPELINE_STAGE_TRANSFER_BIT,</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">    destination_image,</span><br><span class="line">    destination_image_current_access,</span><br><span class="line">    VK_ACCESS_TRANSFER_WRITE_BIT,</span><br><span class="line">    destination_image_current_layout,</span><br><span class="line">    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">    VK_QUEUE_FAMILY_IGNORED,</span><br><span class="line">    VK_QUEUE_FAMILY_IGNORED,</span><br><span class="line">    destination_image_aspect</span><br><span class="line">	&#125; &#125; );</span><br><span class="line">CopyDataFromBufferToImage( command_buffer, staging_buffer,</span><br><span class="line">destination_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        destination_image_subresource,</span><br><span class="line">        destination_image_offset,</span><br><span class="line">        destination_image_size,</span><br><span class="line">    &#125; &#125; );</span><br></pre></td></tr></table></figure>
<p>再次修改image的usag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT,</span><br><span class="line">destination_image_consuming_stages,</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">    destination_image,</span><br><span class="line">    VK_ACCESS_TRANSFER_WRITE_BIT,</span><br><span class="line">    destination_image_new_access,</span><br><span class="line">    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">    destination_image_new_layout,</span><br><span class="line">    VK_QUEUE_FAMILY_IGNORED,</span><br><span class="line">    VK_QUEUE_FAMILY_IGNORED,</span><br><span class="line">    destination_image_aspect</span><br><span class="line">    &#125; &#125; );</span><br><span class="line">    if( !EndCommandBufferRecordingOperation( command_buffer ) ) &#123;</span><br><span class="line">    	return false;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>fence</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VkFence fence;</span><br><span class="line">if( !CreateFence( logical_device, false, fence ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">if( !SubmitCommandBuffersToQueue( queue, &#123;&#125;, &#123; command_buffer &#125;,</span><br><span class="line">signal_semaphores, fence ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">if( !WaitForFences( logical_device, &#123; fence &#125;, VK_FALSE, 500000000 ) ) &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">DestroyBuffer( logical_device, staging_buffer );</span><br><span class="line">FreeMemoryObject( logical_device, memory_object );</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>
<p>如果是用池的话就不需要fence.</p>
<h2 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h2><h3 id="销毁iamge-view"><a href="#销毁iamge-view" class="headerlink" title="销毁iamge view"></a>销毁iamge view</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != buffer_view ) &#123;</span><br><span class="line">vkDestroyBufferView( logical_device, buffer_view, <span class="literal">nullptr</span> );</span><br><span class="line">	buffer_view = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memory-object"><a href="#memory-object" class="headerlink" title="memory object"></a>memory object</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != memory_object ) &#123;</span><br><span class="line">vkFreeMemory( logical_device, memory_object, <span class="literal">nullptr</span> );</span><br><span class="line">	memory_object = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="buffer-1"><a href="#buffer-1" class="headerlink" title="buffer"></a>buffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if( VK_NULL_HANDLE != buffer ) &#123;</span><br><span class="line">vkDestroyBuffer( logical_device, buffer, nullptr );</span><br><span class="line">	buffer = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://noleafnolife.com/2019/04/05/sdk/graphics/vulkan/8.GraphicsandComputePipelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nolife">
      <meta itemprop="description" content="一个游戏程序员的blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stoner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/05/sdk/graphics/vulkan/8.GraphicsandComputePipelines/" class="post-title-link" itemprop="url">Graphics and Compute Pipelines</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-05 21:16:00 / Modified: 21:20:13" itemprop="dateCreated datePublished" datetime="2019-04-05T21:16:00+08:00">2019-04-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/" itemprop="url" rel="index"><span itemprop="name">sdk</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/" itemprop="url" rel="index"><span itemprop="name">graphics</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/sdk/graphics/vulkan/" itemprop="url" rel="index"><span itemprop="name">vulkan</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="Graphics-and-Compute-Pipelines"><a href="#Graphics-and-Compute-Pipelines" class="headerlink" title="Graphics and Compute Pipelines"></a>Graphics and Compute Pipelines</h1><p>[TOC]</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><blockquote>
<ul>
<li>Creating a shader module</li>
<li>Specifying pipeline shader stages</li>
<li>Specifying a pipeline vertex binding description, attribute description, and input<br>state</li>
<li>Specifying a pipeline input assembly state</li>
<li>Specifying a pipeline tessellation state</li>
<li>Specifying a pipeline viewport and scissor test state</li>
<li>Specifying a pipeline rasterization state</li>
<li>Specifying a pipeline multisample state</li>
<li>Specifying a pipeline depth and stencil state</li>
<li>Specifying a pipeline blend state</li>
<li>Specifying pipeline dynamic states</li>
<li>Creating a pipeline layout</li>
<li>Specifying graphics pipeline creation parameters</li>
<li>Creating a pipeline cache object</li>
<li>Retrieving data from a pipeline cache</li>
<li>Merging multiple pipeline cache objects</li>
<li>Creating a graphics pipeline</li>
<li>Creating a compute pipeline</li>
<li>Binding a pipeline object</li>
<li>Creating a pipeline layout with a combined image sampler, a buffer, and push<br>constant ranges</li>
<li>Creating a graphics pipeline with vertex and fragment shaders, depth test<br>enabled, and with dynamic viewport and scissor tests</li>
<li>Creating multiple graphics pipelines on multiple threads</li>
<li>Destroying a pipeline</li>
<li>Destroying a pipeline cache</li>
<li>Destroying a pipeline layout</li>
<li>Destroying a shader module</li>
</ul>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>本文内容是核心之一.</p>
<p>在cb里record和提交给queus的operations由硬件执行.使用compute pipeline进行数学计算,使用graphic pipeline来绘制图形.</p>
<p>Pipeline objects控制geometry绘制和计算的方式.管理硬件的行为.是Vulkan和OpenGL最大的区别之处.它允许我们随时修改rendering或computing参数.我们能设置state,激活shaderprogram,绘制几何体,然后激活另一个shader program绘制另一个几何体.在vulkan里这是不可能的,因为整个rendering或computeingstate存储在一个单片的(monolithical)object里.当使用不同的shaders时,需要准备和使用分开的pipeline.不能switch shaders.</p>
<p>这一开始可能让人害怕,因为很多shader变体(variations)(还不包括额外的pipeline state)可能会创建大量的pipeline objects.但它是为了两个目的服务的,第一是性能.驱动能提前知道整个state以便优化后续操作的执行.第二是稳定性,随时修改state可能让驱动执行额外的操作,比如shader重编译.vulkan中所有需要提前准备的包括shader 编译都在pipeline创建时完成.</p>
<p>本文讨论如何给graphics或compute pipelines 参数进行设置.准备shader modules和决定激活shader stages激活,如何设置depth/stencil tests和如何激活blending.指明vertex attributes以及在绘制操作时时如何提供的.最后看如何创建多pipelines以及如何提高创建速度.</p>
<h2 id="Shader-Module"><a href="#Shader-Module" class="headerlink" title="Shader Module"></a>Shader Module</h2><h3 id="Creating-a-shader-module"><a href="#Creating-a-shader-module" class="headerlink" title="Creating a shader module"></a>Creating a shader module</h3><p>第一件事是为pipeline object准备shader modules.SPIR-V assembly.一个module可能包含多个shader stages.</p>
<p>Shader modules包括选择的shader programs的源码–一个SPIR-V assembly.可能包含多个stages,但每个stage需要有关联的入口(entry point).这些入口作为创建pipeline object的参数之一.</p>
<p>加载SPIR-V code,然后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkShaderModuleCreateInfo shader_module_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    source_code.size(),</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span> <span class="keyword">const</span> *&gt;(source_code.data())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用vkCreateShaderModule</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkCreateShaderModule( logical_device,</span><br><span class="line">&amp;shader_module_create_info, <span class="literal">nullptr</span>, &amp;shader_module );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create a shader module."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>需要记住创建shader module时shader没有编译和链接,而是在创建pipeline object时完成.</p>
<h2 id="pipeline-states"><a href="#pipeline-states" class="headerlink" title="pipeline states"></a>pipeline states</h2><h3 id="Specifying-pipeline-shader-stages"><a href="#Specifying-pipeline-shader-stages" class="headerlink" title="Specifying pipeline shader stages"></a>Specifying pipeline shader stages</h3><p>在compute pipelines,我们只能用compute shaders.但graphics pipeline包括很多shader stages–vertex,geometry,tessellation control and evaluation,fragment.所以为了正确创建pipeline,需要指明哪些可编程shader stages在创建在cb里的pipeline时会被激活.且需要提供激活的shaders的所有源码.</p>
<p>自定义一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">structShaderStageParameters &#123;</span><br><span class="line">    VkShaderStageFlagBits ShaderStage;</span><br><span class="line">    VkShaderModule ShaderModule;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> * EntryPointName;</span><br><span class="line">    VkSpecializationInfo <span class="keyword">const</span> * SpecializationInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>VkSpecializationInfo 用来提供constant变量设置值.可为nullptr.</p>
<p>为了定义一组pipeline要激活的shader stages,需要准备VkPipelineShaderStageCreateInfo的数组.每个shader stage需要一个独立的entry,在entry里指明shader模块以及实现shader行为的入口.</p>
<p>也能提供特殊信息,比如创建时(运行时)修改常量的值,这允许在多次使用相同的shader时有细微变化.</p>
<p>graphics和compute pipelins都需要指明pipeline shader stages信息</p>
<p>假设只使用verte和fragment shaders.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ShaderStageParameters&gt;shader_stage_params = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        VK_SHADER_STAGE_VERTEX_BIT,</span><br><span class="line">        *vertex_shader_module,</span><br><span class="line">        <span class="string">"main"</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">        *fragment_shader_module,</span><br><span class="line">        <span class="string">"main"</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shader_stage_create_infos.clear();</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> &amp; shader_stage : shader_stage_params ) &#123;</span><br><span class="line">    shader_stage_create_infos.push_back( &#123;</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        shader_stage.ShaderStage,</span><br><span class="line">        shader_stage.ShaderModule,</span><br><span class="line">        shader_stage.EntryPointName,</span><br><span class="line">        shader_stage.SpecializationInfo</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个shader stage需要时独一无二的.</p>
<h3 id="Specifying-a-pipelinee-vertex-bindign-description-attribute-description-and-input-state"><a href="#Specifying-a-pipelinee-vertex-bindign-description-attribute-description-and-input-state" class="headerlink" title="Specifying a pipelinee vertex bindign description,attribute description,and input state"></a>Specifying a pipelinee vertex bindign description,attribute description,and input state</h3><p>当想绘制几何体,我们准备额外的属性比如normal vectors,colors,texture coordinates.这些顶点数据是我们可以随意选择的,为了硬件能正确使用它们,我们需要指明有多少属性,内存中如何而排放,或者它们从哪里取.这些通过创建graphics pipeline时verte bindign description和attribute description提供.</p>
<p>veertex binding定义从绑定到选定索引的顶点缓冲区获取的数据集合.此绑定用作顶点属性的编号数据源.我们能至少使用16个分开的bindings,能绑定分开的vertex buffers或同一个buffer的不同memory.</p>
<p>通过binding description,指明数据来自哪里(from which binding),如何存放(缓冲区中连续元素之间的跨距是多少),数据如何读取($\color{red}{逐vertex还是逐instance}$).</p>
<p>一下是一个例子:vec3 position,ve2 texcoord,vec3 color</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkVertexInputBindingDescription&gt; binding_descriptions = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">8</span> * <span class="keyword">sizeof</span>( <span class="keyword">float</span> ),</span><br><span class="line">        VK_VERTEX_INPUT_RATE_VERTEX</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过vertex input description,我们定义了从给定绑定中获取的属性.每个属性需要提供一个shader location(与layout(location=<number>)一样),用于给定属性的数据格式,以及给定属性开始时的内存偏移量(offset).input description 条目数量指明了渲染时属性数量总和.</number></p>
<p><img src="media/vertexdescription.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkVertexInputAttributeDescription&gt; attribute_descriptions = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_FORMAT_R32G32B32_SFLOAT,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_FORMAT_R32G32_SFLOAT,</span><br><span class="line">        <span class="number">3</span> * <span class="keyword">sizeof</span>( <span class="keyword">float</span> )</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_FORMAT_R32G32B32_SFLOAT,</span><br><span class="line">        <span class="number">5</span> * <span class="keyword">sizeof</span>( <span class="keyword">float</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vertex_input_state_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(binding_descriptions.size()),</span><br><span class="line">    binding_descriptions.data(),</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(attribute_descriptions.size()),</span><br><span class="line">    attribute_descriptions.data()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-a-pipeline-input-assembly-state"><a href="#Specifying-a-pipeline-input-assembly-state" class="headerlink" title="Specifying a pipeline input assembly state"></a>Specifying a pipeline input assembly state</h3><p>绘制几何体涉及明确的图元类型,通过input assembly state完成.</p>
<p>VkPipelineInputAssemblyStateCreateInfo</p>
<p>通过input assembly state定义vertices如何组成polygons,最常用的是triangle strips 或Lists.</p>
<p><img src="media/primitivetype.png" alt></p>
<p>注意事项</p>
<blockquote>
<ul>
<li>list primitives不能使用primitive restart选项</li>
<li>primitives with adjacency只能和geometry shaders一起使用过.创建logical device时需要激活geometryShader特性.</li>
<li>当使用tessellation shaders时只能用patch primitives.创建logical device时需要激活tessellationShader特性.</li>
</ul>
<p>VkPipelineInputAssemblyStateCreateInfo:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input_assembly_state_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    topology,</span><br><span class="line">    primitive_restart_enable</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-a-pipeline-tessellation-state"><a href="#Specifying-a-pipeline-tessellation-state" class="headerlink" title="Specifying a pipeline tessellation state"></a>Specifying a pipeline tessellation state</h3><p>为了使用tessellation shaders,需要</p>
<blockquote>
<ul>
<li>创建logicalDevice时激活tessellationShader特性</li>
<li>为tessellation control和evaluation shaders写代码</li>
<li>为他们创建一个shader module(或2个)</li>
<li>准备VkPipelineTessellationStateCreateInfo pipeline tessellation state</li>
</ul>
</blockquote>
<p>VkPipelineTessellationStateCreateInfo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tessellation_state_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    patch_control_points_count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在tessellation state里我们只需要提供形成patch(vertices)的control points信息.至少支持32个vertices.</p>
<p>一个patch就是一组点(vertices),用于tessellation stages生成points,lines,或三角形之类的polygons.作为例子,获取三角形vertices</p>
<p>VkPipelineTessellationStateCreateInfo:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tessellation_state_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    patch_control_points_count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-a-pipeline-viewport-and-scissor-test-state"><a href="#Specifying-a-pipeline-viewport-and-scissor-test-state" class="headerlink" title="Specifying a pipeline viewport and scissor test state"></a>Specifying a pipeline viewport and scissor test state</h3><p>在屏幕上绘制要求指明screen parameters.创建swapchain不够,不总是绘制整个image area.有在一个更小的image上绘制得情况,比如镜面反射,分屏多人游戏.我们定义要通过pipeline viewport和scissor test states绘制到的图像区域</p>
<p>指明viewport和scissor states参数要求给viewport和scissor test提供独立的参数,但数量一致.自定义一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewportInfo</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkViewport&gt; Viewports;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkRect2D&gt; Scissors;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要多viewport渲染，需要在创建logical device时激活multiViewport特性</p>
<p>顶点从局部坐标变换到clip space,硬件做透视出发,成圣normalized device coordinates(标准化设备坐标NDC),然后polygons被assemled和rasterized(光栅化)–产生了fragments,每个fragments有自己的position(由framgbuffer的coordinates定义).为了position被正确计算,需要视口(viewport)变换.这个变换的参数由viewport state指明.</p>
<p>viewport 和 scissor test state是可选的,尽管通常启用.但如果不激活rasterization就不需要提供它们.</p>
<p>viewport state,我们定义framebuffer的coordinate(pixels on screen)的$\color{red}{左上角和width和height}$.也定义iewport depth值得最小、最大值(floating-point $\in$[0,1]).最大深度比最小深度小也是合法的.</p>
<p>scissor test允许对生成的fragments用指明的矩形做额外的clip操作.如果不想做clip操作,可以指明一个viewport大小的区域.</p>
<p>Vulkan里scissort test一直开启.</p>
<p>一个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ViewportInfo viewport_infos = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">512.0f</span>,</span><br><span class="line">            <span class="number">512.0f</span>,</span><br><span class="line">            <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">512</span>,</span><br><span class="line">                <span class="number">512</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前面的变量可用于创建此配方中定义的viewport和scissor test.实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> viewport_count =</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(viewport_infos.Viewports.size());</span><br><span class="line"><span class="keyword">uint32_t</span> scissor_count =</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(viewport_infos.Scissors.size());</span><br><span class="line">viewport_state_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    viewport_count,</span><br><span class="line">    viewport_infos.Viewports.data(),</span><br><span class="line">    scissor_count,</span><br><span class="line">    viewport_infos.Scissors.data()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果想改变viewport或scissor test参数,需要重建pipeline.但是在创建pipeline时可以指明viewport和scissor test parameters是动态的(dynamic).这样就不用重建pipeline就能改变这些参数了.可以在command buffer recording过程中指明.但是viewport和scissor tests的数量是pipeline 创建时指定的.之后不能改.</p>
<p>除非创建logical device时激活了multiViewport特性,否则不能提供一个以上的viewport和scissor test.</p>
<p>只能在geometry shaders内更改用于rasterization的viewport transformation的index.</p>
<h3 id="Specifying-a-pipeline-rasterzation-state"><a href="#Specifying-a-pipeline-rasterzation-state" class="headerlink" title="Specifying a pipeline rasterzation state"></a>Specifying a pipeline rasterzation state</h3><p>rasterization process将assembled polygons生成fragments(pixels).viewport state在这使用,fragments会生成到framebuffer coordinates.为了觉得fragments如何生成,我们需要准备rasterization state.</p>
<p>rasterization state控制rasterization的参数.首先最重要的是它定义是否开启rasterization.能指明polygon哪一侧是front–是顶点在屏幕上按顺时针顺序(clockwise)出现或按逆时针(counterclockwise)顺序出现的.是否进行front,back,both faces culling.OpenGL中默认逆时针表面为正面且culling关闭.vulkan没有默认值.</p>
<p>一个rasterization state在graphics pipeline创建时总是需要的.</p>
<p>rasterization state也控制polygons绘制的方式.通常需要fully rendered(filled).但也能指明是否只绘制edges(lines)或者points(vertices).Line或points模式只有在创建logical device时激活了fillModeNoSolid特性时才能用.</p>
<p>还需要定义fragment的深度值如何计算,能够开启depth bias–一个给生成的depth value进行offset并添加slope factor的过程.也需要指明当depth bias激活时能给depth value加上的最大的(最小的)offset值.</p>
<p>这之后,也需要定义如果深度超过viewport state给定的范围怎么做.当depth clamp激活,会进行clamp.如果没有,fragment会discarded.(默认应该是disable)</p>
<p>最后一件事,定义绘制的lines的夸大怒,通常指明为1.但如果激活wideLines特性,能提供大于1的值.</p>
<p>同理,设置point size.</p>
<p>其实这些值在shader里可以对定点进行设置</p>
<p>VkPipelineRasterizationStateCreateInfo.</p>
<p>一个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineRasterizationStateCreateInfo rasterization_state_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    depth_clamp_enable,</span><br><span class="line">    rasterizer_discard_enable,</span><br><span class="line">    polygon_mode,</span><br><span class="line">    culling_mode,</span><br><span class="line">    front_face,</span><br><span class="line">    depth_bias_enable,</span><br><span class="line">    depth_bias_constant_factor,</span><br><span class="line">    depth_bias_clamp,</span><br><span class="line">    depth_bias_slope_factor,</span><br><span class="line">    line_width</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-a-pipeline-multisample-state"><a href="#Specifying-a-pipeline-multisample-state" class="headerlink" title="Specifying a pipeline multisample state"></a>Specifying a pipeline multisample state</h3><p>多重采用(multisampling)是绘制primitives时抗锯齿(eliminates jagged edges)的proceess.换句话说,它可以anti-alias polygons,lines and points.通过multisample state控制.</p>
<p>VkPipelineMultisampleStateCreateInfo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">multisample_state_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    sample_count,<span class="comment">//the number of samples generated per fragment</span></span><br><span class="line">    per_sample_shading_enable,<span class="comment">//</span></span><br><span class="line">    min_sample_shading,<span class="comment">//minimal number of uniquely shaded samples</span></span><br><span class="line">    sample_masks,<span class="comment">//fragment的覆盖范围参数</span></span><br><span class="line">    alpha_to_coverage_enable,<span class="comment">//是否从alpha分量生成coverage</span></span><br><span class="line">    alpha_to_one_enable<span class="comment">//是否alpha用1.0替代</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-a-pipeline-depth-and-stencil-state"><a href="#Specifying-a-pipeline-depth-and-stencil-state" class="headerlink" title="Specifying a pipeline depth and stencil state"></a>Specifying a pipeline depth and stencil state</h3><p>depth test (never, less, less and equal, equal,greater and equal, greater, not equal, always)</p>
<p>stencil test compareOp(never, less, less and equal, equal,greater and equal, greater, not equal, always)</p>
<p>dpeth 和 stencil state在rasterization为非激活或render pass给定的subpass没有用depth/stencil attachment时不需要.</p>
<p>需要指明depth value如何比较的以及通过测试的fragment是否写入depth attachment.</p>
<p>当depthBounds 特性激活时,能使用额外的depth bounds test.这个测试监测fragment是否在特定的minDepthBounds-maxDepthBounds范围内.如果不是discard(failed the depth test).</p>
<p>stencil test对每个fragment与一个integer 值进行额外的test.能用于多种目的,比如能定义复杂的图形决定哪块区域需要渲染,在defered shading/lighting中决定哪块区域进行lit,还有渲染鼠标选中物体的轮廓(高亮)都很有用,以及渲染隐藏在物体后面的物体的轮廓.</p>
<p>在激活stencil test的情况下,我们需要给front and back -facing polygons定义参数.这些参数在:fragment stencil test失败;stencil test成功但depth test失败;stencil test和depth test都成功的情况下执行什么行动.对于每种情况定义一些模式:保持不变;重置为0;替换为参考值;clamp(saturate)递增或递减;按位倒转.也指明进行comparison操作时test如何操作(与depth test类似),比较和写入模板,选择应参与测试或应在模板attachment中更新的stencil value’s bits,以及参考值.</p>
<p>VkPipelineDepthStencilStateCreateInfo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineDepthStencilStateCreateInfo depth_and_stencil_state_create_info =</span><br><span class="line">&#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    depth_test_enable,</span><br><span class="line">    depth_write_enable,</span><br><span class="line">    depth_compare_op,</span><br><span class="line">    depth_bounds_test_enable,</span><br><span class="line">    stencil_test_enable,</span><br><span class="line">    front_stencil_test_parameters,</span><br><span class="line">    back_stencil_test_parameters,</span><br><span class="line">    min_depth_bounds,</span><br><span class="line">    max_depth_bounds</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-a-pipeline-blend-state"><a href="#Specifying-a-pipeline-blend-state" class="headerlink" title="Specifying a pipeline blend state"></a>Specifying a pipeline blend state</h3><p>为了模拟透明物体,硬件通过混合存储在framebuffer里的已经渲染的fragment的颜色,通过graphics pipeline的blend state准备这个操作.</p>
<p>VkPipelineColorBlendAttachmentState</p>
<p>VkPipelineColorBlendStateCreateInfo</p>
<p>blending state是可选的且在rasterization非激活状态时或graphics pipeline的subpass没有color attachment是不要求的.</p>
<p>blending state主要是定义blending 操作的参数.但它也有其他用处,指明color mask选择渲染时哪个color components刷新(written to).控制logical operation 状态.当激活时,在当前fragment color和已经写入framebuffer的color 执行指定的逻辑操作.</p>
<p>仅对具有整数和规范化整数格式的attachment执行逻辑操作.</p>
<p>支持的logical 操作</p>
<blockquote>
<ul>
<li>CLEAR: Setting the color to zero</li>
<li>AND: Bitwise AND operation between the source (fragment’s) color and a<br>destination color (already stored in an attachment)</li>
<li>AND_REVERSE: Bitwise AND operation between source and inverted destination<br>colors</li>
<li>COPY: Copying the source (fragment’s) color without any modifications<br>AND_INVERTED: Bitwise AND operation between destination and inverted source<br>colors</li>
<li>NO_OP: Leaving the already stored color intact</li>
<li>XOR: Bitwise excluded OR between source and destination colors</li>
<li>OR: Bitwise OR operation between the source and destination colors</li>
<li>NOR: Inverted bitwise OR</li>
<li>EQUIVALENT: Inverted XOR</li>
<li>INVERT: Inverted destination color</li>
<li>OR_REVERSE: Bitwise OR between the source color and inverted destination color</li>
<li>COPY_INVERTED: Copying bitwise inverted source color</li>
<li>OR_INVERTED: Bitwise OR operation between destination and inverted source<br>color</li>
<li>NAND: Inverted bitwise AND operation<br>SET: Setting all color bits to ones</li>
</ul>
</blockquote>
<p>blending操作对给定graphic pipeline的subpass的每个color attachment是分开的.也就是说需要给每个color attachment指定blending 参数.但如果independentBlend特性没有启用,每个attachment的blending参数必须一样.</p>
<p>对blending,我们为color components和alpha component分别指明source和destination factors.支持的blend factors包括:</p>
<blockquote>
<ul>
<li>ZERO: 0</li>
<li>ONE: 1</li>
<li>SRC_COLOR: <source component></li>
<li>ONE_MINUS_SRC_COLOR: 1 - <source component></li>
<li>DST_COLOR: <destination component></destination></li>
<li>ONE_MINUS_DST_COLOR: 1 - <destination component></destination></li>
<li>SRC_ALPHA: <source alpha></li>
<li>ONE_MINUS_SRC_ALPHA: 1 - <source alpha></li>
<li>DST_ALPHA: <destination alpha></destination></li>
<li>ONE_MINUS_DST_ALPHA: 1 - <destination alpha></destination></li>
<li>CONSTANT_COLOR: <constant color component></constant></li>
<li>ONE_MINUS_CONSTANT_COLOR: 1 - <constant color component></constant></li>
<li>CONSTANT_ALPHA: <alpha value of a constant color></alpha></li>
<li>ONE_MINUS_CONSTANT_ALPHA: 1 - <alpha value of a constant color></alpha></li>
<li>SRC_ALPHA_SATURATE: min( <source alpha>, 1 - <destination alpha><br>)</destination></li>
<li>SRC1_COLOR: &lt;component of a source’s second color&gt; (used in dual<br>source blending)</li>
<li>ONE_MINUS_SRC1_COLOR: 1 - &lt;component of a source’s second color&gt;<br>(from dual source blending)</li>
<li>SRC1_ALPHA: &lt;alpha component of a source’s second color&gt; (in dual<br>source blending)</li>
<li>ONE_MINUS_SRC1_ALPHA: 1 - &lt;alpha component of a source’s second<br>color&gt; (from dual source blending)</li>
</ul>
</blockquote>
<p>有些blendingg factors使用constant color而不是fragment的(source)color或者存储在attachment的color(destination).这个constant color可以在创建Pipeline是静态指定货在command buffer recording调用vkCmdSetBlendConstants()动态设置.</p>
<p>其中use the source’s second color(SRC1)只在dualSrcBlend特性开启式有效.</p>
<p>控制如何blending的blending function也能为color和alpha分量分开指定.Blending operators包括:</p>
<blockquote>
<ul>
<li>ADD: <src component> <em> <src factor> + <dst component> </dst></src></em> <dst factor></dst></src></li>
<li>SUBTRACT: <src component> <em> <src factor> - <dst component> </dst></src></em><dst factor></dst></src></li>
<li>REVERSE_SUBTRACT: <dst component> <em> <dst factor> - <src component> </src></dst></em> <src factor></src></dst></li>
<li>MIN: min( <src component>, <dst component> )</dst></src></li>
<li>MAX: max( <src component>, <dst component> )</dst></src></li>
</ul>
</blockquote>
<p> Enabling a logical operation disables blending.</p>
<p>下面是disabled logical operation和blending操作的blend state的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkPipelineColorBlendAttachmentState&gt; attachment_blend_states =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  VK_BLEND_FACTOR_ONE,</span><br><span class="line">  VK_BLEND_FACTOR_ONE,</span><br><span class="line">  VK_BLEND_OP_ADD,</span><br><span class="line">  VK_BLEND_FACTOR_ONE,</span><br><span class="line">  VK_BLEND_FACTOR_ONE,</span><br><span class="line">  VK_BLEND_OP_ADD,</span><br><span class="line">  VK_COLOR_COMPONENT_R_BIT |</span><br><span class="line">  VK_COLOR_COMPONENT_G_BIT |</span><br><span class="line">  VK_COLOR_COMPONENT_B_BIT |</span><br><span class="line">  VK_COLOR_COMPONENT_A_BIT</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> VkPipelineColorBlendStateCreateInfo blend_state_create_info;</span><br><span class="line"> SpecifyPipelineBlendState( <span class="literal">false</span>, VK_LOGIC_OP_COPY,</span><br><span class="line"> attachment_blend_states, &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;,</span><br><span class="line"> blend_state_create_info );</span><br></pre></td></tr></table></figure>
<p> 这种recipe实现fillsVkPipelineColorBlendStateCreateInfo如下</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">blend_state_create_info = &#123;</span><br><span class="line"> VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,</span><br><span class="line"> <span class="literal">nullptr</span>,</span><br><span class="line"> <span class="number">0</span>,</span><br><span class="line"> logic_op_enable,</span><br><span class="line"> logic_op,</span><br><span class="line"> <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(attachment_blend_states.size()),</span><br><span class="line"> attachment_blend_states.data(),</span><br><span class="line"> &#123;</span><br><span class="line">     blend_constants[<span class="number">0</span>],</span><br><span class="line">     blend_constants[<span class="number">1</span>],</span><br><span class="line">     blend_constants[<span class="number">2</span>],</span><br><span class="line">     blend_constants[<span class="number">3</span>]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-pipeline-dynamic-states"><a href="#Specifying-pipeline-dynamic-states" class="headerlink" title="Specifying pipeline dynamic states"></a>Specifying pipeline dynamic states</h3><p>创建graphic pipeline要求提供很多参数,且不再能修改,专业能提高性能,能给驱动提供稳定的可预测的环境.但不幸的是,给开发者造成了不便,使得可能需要创建很多pipeline objects–但只有很少的不同.</p>
<p>为了避免这个问题,引入了dynamic states.它允许我们再command bufferrecording specific函数动态控制pipeline的参数.为了做到这,需要指明pipeline的那部分时dynamic.这通过指明pipeline dynamic states实现.</p>
<p>VkDynamicState</p>
<blockquote>
<ul>
<li>VK_DYNAMIC_STATE_VIEWPORT</li>
<li>VK_DYNAMIC_STATE_SCISSOR</li>
<li>VK_DYNAMIC_STATE_LINE_WIDTH</li>
<li>VK_DYNAMIC_STATE_DEPTH_BIAS</li>
<li>VK_DYNAMIC_STATE_BLEND_CONSTANTS</li>
<li>VK_DYNAMIC_STATE_DEPTH_BOUNDS</li>
<li>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</li>
<li>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</li>
<li>VK_DYNAMIC_STATE_STENCIL_REFERENCE</li>
</ul>
</blockquote>
<p>dynamic pipeline states被引入允许设置pipeline objects的state.在命令缓冲区记录期间,可能没有太多不同的管道部分可以设置,但是选择需要在性能、驱动程序的简单性、现代硬件的功能和API的易用性之间的折衷.</p>
<p>dynamic state时可选的.</p>
<p>一下是可以被动态设置的部分:</p>
<blockquote>
<ul>
<li>Viewport</li>
<li>Scissor</li>
<li>Line width</li>
<li>Depth bias</li>
<li>Stencil compare mask</li>
<li>Stencil write mask</li>
<li>Stencil reference value</li>
<li>Blend constants</li>
</ul>
</blockquote>
<p>通过VkDynamicState数组指明哪些state需要动态设置,然后通过VkPipelineDynamicStateCreateInfo结构记录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineDynamicStateCreateInfo dynamic_state_creat_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(dynamic_states.size()),</span><br><span class="line">    dynamic_states.data()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><h3 id="Creating-a-pipeline-layout"><a href="#Creating-a-pipeline-layout" class="headerlink" title="Creating a pipeline layout"></a>Creating a pipeline layout</h3><p>Pipeline layouts和descriptor set layouts类似.Descriptor set layouts用来定义什么类型的resources形成descriptor set.Pipeline layouts定义什么类型的资源能被pipeline 访问.它们通过descriptor set layouts创建并push constant ranges</p>
<p>在pipeline创建时需要pipeline layouts,因为它们通过a set,binding,array element address指明了shader stages和shader resources间的接口.shaders使用同样的address(through a lyout qualifier)能访问给定resources.但是,即使给定的管道不使用任何描述符资源,我们也需要创建一个管道布局来通知驱动程序不需要这样的接口.</p>
<p>pipeline layout定义了pipeline 的shaders能访问的resources集合.当record command buffers时,我们绑定descriptor set to 选定的indices(Binding descriptor sets).descriptor set layout的index与关联的Pipeline layout的数组的index一致.同样的index在shaders中通过layout(set = <index>,binding=<number>)qualifier指定以访问所给资源.</number></index></p>
<p><img src="media/pipelinelayout.png" alt></p>
<p>通常multiple pipelines会访问不同的resources.在command buffer recording,绑定pipeilne 和descriptor sets.只有这样才能issue dcs.当我们切换pipeline,需要根据pipeline的需要绑定信的descriptor sets.但频繁绑定不同descriptor sets会影响app的性能.这也是创建由相似(or compatible)layouts的pipelines和绑定不常改变的descriptor sets(that are common for many pipelines)到indices接近0(或靠近layout开始的地方).这样,当我们switch pipelines,descriptor sets.这样,当切换pipelines时,descriptor sets靠近pipeline layout 开始的地方(from index 0 to some index N)能继续用且不用更新.只有在绑定不同descriptor sets(由更高indices,在index N之后),才有必要.但需要注意,为了similar(or compatible),pipeline layouts必须由相同的push constant ranges.</p>
<p>我们需要将很多pipelines通用的descriptor sets绑定到pipeline layout靠近开始的地方(near the $0^{th}$ index)</p>
<p>pipeline layouts也定义了push constants的ranges.能提供一个小的constant values集合给shaders.比更新descriptor sets快,但memory更小,最少只有128bytes(in a pipeline layout).</p>
<p>比如,我们能给graphics pipeline每个state提供不同的range.每个stage128/5=26bytes.也可以给多个shader stage提供相同的ranges.但每个shader stage只能访问一个push constant range.</p>
<p>通常是不需要push constant ranges的,所以上述例子是比较糟糕的情况.一般由足够的内存存储若干vec4或1、2个matrix</p>
<p>需要注意push constant range的size和offset必须为4的倍数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineLayoutCreateInfo pipeline_layout_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(descriptor_set_layouts.size()),</span><br><span class="line">    descriptor_set_layouts.data(),</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(push_constant_ranges.size()),</span><br><span class="line">    push_constant_ranges.data()</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreatePipelineLayout( logical_device,</span><br><span class="line">                                         &amp;pipeline_layout_create_info, <span class="literal">nullptr</span>, &amp;pipeline_layout );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create pipeline layout."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-graphics-pipeline-creation-parameters"><a href="#Specifying-graphics-pipeline-creation-parameters" class="headerlink" title="Specifying graphics pipeline creation parameters"></a>Specifying graphics pipeline creation parameters</h3><p>创建graphic pipeline需要填VkGraphicsPipelineCreateInfo提供很多控制不同方面的内容的参数.</p>
<p>在pipeline创建阶段能提供很多VkGraphicsPipelineCreateInfo,每一个指明了会被创建的单个pipeline的属性.</p>
<p>创建graphic pipeline后,可以在recording a dc前将之绑定到cb.Graphic pipeline只能在render pass绑定cb.在pipeline创建时,我们指明在哪个render pass这个pipeline会被爱使用.如果render pass是compatible那么可以使用同一个pipeline.</p>
<p>很少pipeline没有公共state.所以为了加快速度,可以$\color{red}{指明一个pipeline称为其他pipeline的parent(allow dervatives)}$,使用VkGraphicsPipelineCreateInfob的basePipelineHandle或basePipelineIndex.</p>
<p>basePipelineHandle允许我们指明已经存在的pipeline的handle,作为parent</p>
<p>basePipelineIndex当一次创建多Pipelines时,能指明VkGraphicsPipelineCreateInfo数组的哪个index提供给vkCreateGraphicsPipelines().此索引指向将与子pipeline一起在同一个单函数调用中创建的父管道.因为一起创建的所以无法提供handle.要求是parent的index必须必其他的小.也就是先创建.</p>
<p>basePipelineHandle和basePipelineIndex不能同时使用.</p>
<p>下面是一个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">VkGraphicsPipelineCreateInfo graphics_pipeline_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    additional_options,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(shader_stage_create_infos.size()),</span><br><span class="line">    shader_stage_create_infos.data(),</span><br><span class="line">    &amp;vertex_input_state_create_info,</span><br><span class="line">    &amp;input_assembly_state_create_info,</span><br><span class="line">    &amp;tessellation_state_create_info,</span><br><span class="line">    &amp;viewport_state_create_info,</span><br><span class="line">    &amp;rasterization_state_create_info,</span><br><span class="line">    &amp;multisample_state_create_info,</span><br><span class="line">    &amp;depth_and_stencil_state_create_info,</span><br><span class="line">    &amp;blend_state_create_info,</span><br><span class="line">    &amp;dynamic_state_creat_info,</span><br><span class="line">    pipeline_layout,</span><br><span class="line">    render_pass,</span><br><span class="line">    subpass,</span><br><span class="line">    base_pipeline_handle,</span><br><span class="line">    base_pipeline_index</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="color-red-Creating-a-pipeline-cache-object"><a href="#color-red-Creating-a-pipeline-cache-object" class="headerlink" title="$\color {red}{Creating\ a\ pipeline\ cache\ object}$"></a>$\color {red}{Creating\ a\ pipeline\ cache\ object}$</h3><p>一个pipeline object不只是对参数进行包装.它包括所有可编程states和fixed pipeline stages的准备,设置shaders和descriptor resources间的interface,compiling和linking shader programs,进行错误检查(检查shaders是否正确linked).这些结果会存在cache里.这个cache能在创建相似属性的pipeline objects是复用加速.</p>
<p>VkPipelineCacheCreateInfo</p>
<p>VkPipelineCache</p>
<p>vkCreatePipelineCache</p>
<p>pipeline cache存储着一个pipeline preparation process的结果.可选的且能省略的.但能显著加快创建pipeline objects的速度.</p>
<p>在创建Pipeline时使用cache需要先创建一个pipeline cache object并提供给Pipeline creating function.驱动会自动缓存结果.如果cache有数据,driver自动尝试在创建pipeline时使用它.</p>
<p>使用pipeline cache object最常用的剧本(scenario)是将它的内容存储到一个file并在相同的app的独立的executions中复用.当启动app时,创建一个所有pipelines需要的empty cache.然后检索这个cache data并存储到file里.下次app执行时,也创建这个cache,但这次从文件读取数据来初始化它.但如果是只创建少量的pipelines,可能不用这么复杂.但是现代3D app都需要大量的pipelines.这种技术能极大加快初始化速度.</p>
<p>假设cache数据存储在cache_data数组里,可能是空的也可能是从先前创建的数据初始化了,创建pipeline cache的process如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineCacheCreateInfo pipeline_cache_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(cache_data.size()),</span><br><span class="line">    cache_data.data()</span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreatePipelineCache( logical_device,</span><br><span class="line">                                        &amp;pipeline_cache_create_info, <span class="literal">nullptr</span>, &amp;pipeline_cache );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create pipeline cache."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Retrieving-data-from-a-pipeline-cache"><a href="#Retrieving-data-from-a-pipeline-cache" class="headerlink" title="Retrieving data from a pipeline cache"></a>Retrieving data from a pipeline cache</h3><p>为了能复用pipeline cache,我们需要存储cache的内容并在任何时候复用它.为此,我们检索cache里的数据.</p>
<p>vkGetPipelineCacheData</p>
<p>检索pipeliine cache内容是Vulkan里典型的doule-call of a single function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> data_size = <span class="number">0</span>;</span><br><span class="line">VkResult result = VK_SUCCESS;</span><br><span class="line">result = vkGetPipelineCacheData( logical_device, pipeline_cache,</span><br><span class="line">                                &amp;data_size, <span class="literal">nullptr</span> );</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS != result) ||</span><br><span class="line">   (<span class="number">0</span> == data_size) ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not get the size of the pipeline cache."</span> &lt;&lt;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipeline_cache_data.resize( data_size );</span><br><span class="line">result = vkGetPipelineCacheData( logical_device, pipeline_cache,</span><br><span class="line">                                &amp;data_size, pipeline_cache_data.data());</span><br><span class="line"><span class="keyword">if</span>( (VK_SUCCESS != result) ||</span><br><span class="line">   (<span class="number">0</span> == data_size) ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not acquire pipeline cache data."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Merging-multiple-pipeline-cache-objects"><a href="#Merging-multiple-pipeline-cache-objects" class="headerlink" title="Merging multiple pipeline cache objects"></a>Merging multiple pipeline cache objects</h3><p>因为要创建大量的pipelines,为了缩短创建时间,通过多线程将他们创建过程分开.每个线程会使用一个独立的pipeline cache.当都完成后,为了复用cache,需要合并他们到一个cache objects里.</p>
<p>vkMergePipelineCaches</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkResult result = vkMergePipelineCaches( logical_device,</span><br><span class="line">                                        target_pipeline_cache,</span><br><span class="line">                                        <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(source_pipeline_caches.size()),</span><br><span class="line">                                        source_pipeline_caches.data() );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not merge pipeline cache objects."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>注意合并后的那个cache object不能在vector里.</p>
<h3 id="Creating-a-grphics-pipeline"><a href="#Creating-a-grphics-pipeline" class="headerlink" title="Creating a grphics pipeline"></a>Creating a grphics pipeline</h3><p>graphics pipeline控制所有drawing相关的操作.通过它我们指明drawing阶段的shader programs,各种测试(depth,stencil)的参数,或者final color如何计算并写入any of the subpass attachments.是最重要的objects之一.能创建一个或一次创建多个.</p>
<p>vkCreateGraphicsPipelines</p>
<p>下图白色blocks为可编程stages,灰色为固定管线部分</p>
<p><img src="media/graphicspipeline1.png" alt></p>
<p>其中有的是可选的.如果Rasterization关闭,就不需要Fragment stage.如果启用tessellation stage,就需要提供Tessellation control 和 evaluation shaders.</p>
<p>VkGraphicsPipelineCreateInfo</p>
<p>VkPipeline</p>
<p>二者大小相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graphics_pipelines.resize( graphics_pipeline_create_infos.size() );</span><br><span class="line">VkResult result = vkCreateGraphicsPipelines( logical_device,</span><br><span class="line">                                            pipeline_cache,</span><br><span class="line">                                            <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(graphics_pipeline_create_infos.size()),</span><br><span class="line">                                            graphics_pipeline_create_infos.data(), <span class="literal">nullptr</span>, graphics_pipelines.data()</span><br><span class="line">                                           );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create a graphics pipeline."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Creating-a-compute-pipeline"><a href="#Creating-a-compute-pipeline" class="headerlink" title="Creating a compute pipeline"></a>Creating a compute pipeline</h3><p>VkPipelineShaderStageCreateInfo</p>
<p>VkComputePipelineCreateInfo</p>
<p>VkPipeline</p>
<p>vkCreateComputePipelines</p>
<p>一个compute pipeline  只有一个compute shader stage.(尽管硬件可能实现额外的stages)</p>
<p>compute shader只有一些内置变量,没有输入输出.只能用uniform 变量(buffers or images).所以compute shader更通用,能对images执行数学计算.</p>
<p>与graphics pipelines类似,也有继承.</p>
<p>下面是一个简单例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VkComputePipelineCreateInfo compute_pipeline_create_info = &#123;</span><br><span class="line">    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    additional_options,</span><br><span class="line">    compute_shader_stage,</span><br><span class="line">    pipeline_layout,</span><br><span class="line">    base_pipeline_handle,</span><br><span class="line">    <span class="number">-1</span></span><br><span class="line">&#125;;</span><br><span class="line">VkResult result = vkCreateComputePipelines( logical_device, pipeline_cache,</span><br><span class="line">                                           <span class="number">1</span>, &amp;compute_pipeline_create_info, <span class="literal">nullptr</span>, &amp;compute_pipeline );</span><br><span class="line"><span class="keyword">if</span>( VK_SUCCESS != result ) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not create compute pipeline."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Binding-a-pipeline-object"><a href="#Binding-a-pipeline-object" class="headerlink" title="Binding a pipeline object"></a>Binding a pipeline object</h3><p>在issue dc或dispatch computational work前,需要设置所有需要的states.其一为cb绑定pipeline object,graphic piepeline 或compute pipeline.</p>
<p>VkCommandBuffer</p>
<p>vkCmdBindPipeline</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vkCmdBindPipeline( command_buffer, pipeline_type, pipeline );</span><br></pre></td></tr></table></figure>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><h3 id="Creating-a-pipeline-layout-with-a-combined-image-sampler-a-buffer-and-push-constant-ranges"><a href="#Creating-a-pipeline-layout-with-a-combined-image-sampler-a-buffer-and-push-constant-ranges" class="headerlink" title="Creating a pipeline layout with a combined image sampler, a buffer,and push constant ranges"></a>Creating a pipeline layout with a combined image sampler, a buffer,and push constant ranges</h3><p>fragment有一个image,vertex有一个uniform</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkDescriptorSetLayoutBinding&gt; descriptor_set_layout_bindings =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        VK_SHADER_STAGE_VERTEX_BIT,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>( !CreateDescriptorSetLayout( logical_device,</span><br><span class="line">                               descriptor_set_layout_bindings, descriptor_set_layout ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ranges of push constants</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !CreatePipelineLayout( logical_device, &#123; descriptor_set_layout &#125;,</span><br><span class="line">                          push_constant_ranges, pipeline_layout ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Creating-a-graphics-pipeline-with-vertex-andfragment-shaders-depth-test-enabled-and-with-dynamic-viewport-and-scissor-tests"><a href="#Creating-a-graphics-pipeline-with-vertex-andfragment-shaders-depth-test-enabled-and-with-dynamic-viewport-and-scissor-tests" class="headerlink" title="Creating a graphics pipeline with vertex andfragment shaders, depth test enabled, and with dynamic viewport and scissor tests"></a>Creating a graphics pipeline with vertex andfragment shaders, depth test enabled, and with dynamic viewport and scissor tests</h3><h2 id="desctroy"><a href="#desctroy" class="headerlink" title="desctroy"></a>desctroy</h2><p>本节介绍一个通用的graphic pipeline 创建过程,vertex shaders,fragment shaders,depth test enabled.动态指明viewport 和 sicssor tests.</p>
<p>准备vertex和fragment shader stages</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; vertex_shader_spirv;</span><br><span class="line"><span class="keyword">if</span>( !GetBinaryFileContents( vertex_shader_filename, vertex_shader_spirv ) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">VkDestroyer&lt;VkShaderModule&gt; vertex_shader_module( logical_device );</span><br><span class="line"><span class="keyword">if</span>( !CreateShaderModule( logical_device, vertex_shader_spirv,</span><br><span class="line">                        *vertex_shader_module ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; fragment_shader_spirv;</span><br><span class="line"><span class="keyword">if</span>( !GetBinaryFileContents( fragment_shader_filename, fragment_shader_spirv</span><br><span class="line">) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">VkDestroyer&lt;VkShaderModule&gt; fragment_shader_module( logical_device );</span><br><span class="line"><span class="keyword">if</span>( !CreateShaderModule( logical_device, fragment_shader_spirv,</span><br><span class="line">                        *fragment_shader_module ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ShaderStageParameters&gt; shader_stage_params = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        VK_SHADER_STAGE_VERTEX_BIT,</span><br><span class="line">        *vertex_shader_module,</span><br><span class="line">        <span class="string">"main"</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">        *fragment_shader_module,</span><br><span class="line">        <span class="string">"main"</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkPipelineShaderStageCreateInfo&gt; shader_stage_create_infos;</span><br><span class="line">SpecifyPipelineShaderStages( shader_stage_params, shader_stage_create_infos</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>然后选择vertex bindings和verte attributes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineVertexInputStateCreateInfo vertex_input_state_create_info;</span><br><span class="line">SpecifyPipelineVertexInputState( vertex_input_binding_descriptions,</span><br><span class="line">                                vertex_attribute_descriptions, vertex_input_state_create_info );</span><br><span class="line">VkPipelineInputAssemblyStateCreateInfo input_assembly_state_create_info;</span><br><span class="line">SpecifyPipelineInputAssemblyState( primitive_topology,</span><br><span class="line">                                  primitive_restart_enable, input_assembly_state_create_info );</span><br></pre></td></tr></table></figure>
<p>Viewport和scissor test参数很重要,因为动态设置,所以只有viewports的数量重要.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ViewportInfo viewport_infos = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">500.0f</span>,</span><br><span class="line">            <span class="number">500.0f</span>,</span><br><span class="line">            <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">1.0f</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">500</span>,</span><br><span class="line">                <span class="number">500</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">VkPipelineViewportStateCreateInfo viewport_state_create_info;</span><br><span class="line">SpecifyPipelineViewportAndScissorTestState( viewport_infos,</span><br><span class="line">                                           viewport_state_create_info );</span><br></pre></td></tr></table></figure>
<p>然后为rasterization 和 multisample states准备参数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineRasterizationStateCreateInfo rasterization_state_create_info;</span><br><span class="line">SpecifyPipelineRasterizationState( <span class="literal">false</span>, <span class="literal">false</span>, polygon_mode,</span><br><span class="line">                                  culling_mode, front_face, <span class="literal">false</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">                                  rasterization_state_create_info );</span><br><span class="line">VkPipelineMultisampleStateCreateInfo multisample_state_create_info;</span><br><span class="line">SpecifyPipelineMultisampleState( VK_SAMPLE_COUNT_1_BIT, <span class="literal">false</span>, <span class="number">0.0f</span>,</span><br><span class="line">                                <span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>, multisample_state_create_info );</span><br></pre></td></tr></table></figure>
<p>dpeth test.一般而言需要靠近摄像机的fragment得到保留,所以使用VK_COMPARE_OP_LESS_OR_EQUAL作为比较操作.这里假设stencil test关闭</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VkStencilOpState stencil_test_parameters = &#123;</span><br><span class="line">    VK_STENCIL_OP_KEEP,</span><br><span class="line">    VK_STENCIL_OP_KEEP,</span><br><span class="line">    VK_STENCIL_OP_KEEP,</span><br><span class="line">    VK_COMPARE_OP_ALWAYS,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">VkPipelineDepthStencilStateCreateInfo depth_and_stencil_state_create_info;</span><br><span class="line">SpecifyPipelineDepthAndStencilState( <span class="literal">true</span>, <span class="literal">true</span>,</span><br><span class="line">                                    VK_COMPARE_OP_LESS_OR_EQUAL, <span class="literal">false</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="literal">false</span>,</span><br><span class="line">                                    stencil_test_parameters, stencil_test_parameters,</span><br><span class="line">                                    depth_and_stencil_state_create_info );</span><br></pre></td></tr></table></figure>
<p>blending parameters</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineColorBlendStateCreateInfo blend_state_create_info;</span><br><span class="line">SpecifyPipelineBlendState( logic_op_enable, logic_op,</span><br><span class="line">                          attachment_blend_states, blend_constants, blend_state_create_info );</span><br></pre></td></tr></table></figure>
<p>list of dynamic states</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkDynamicState&gt; dynamic_states = &#123;</span><br><span class="line">    VK_DYNAMIC_STATE_VIEWPORT,</span><br><span class="line">    VK_DYNAMIC_STATE_SCISSOR</span><br><span class="line">&#125;;</span><br><span class="line">VkPipelineDynamicStateCreateInfo dynamic_state_create_info;</span><br><span class="line">SpecifyPipelineDynamicStates( dynamic_states, dynamic_state_create_info );</span><br></pre></td></tr></table></figure>
<p>创建pipeline</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">VkGraphicsPipelineCreateInfo graphics_pipeline_create_info;</span><br><span class="line">SpecifyGraphicsPipelineCreationParameters( additional_options,</span><br><span class="line">                                          shader_stage_create_infos, vertex_input_state_create_info,</span><br><span class="line">                                          input_assembly_state_create_info, <span class="literal">nullptr</span>, &amp;viewport_state_create_info,</span><br><span class="line">                                          rasterization_state_create_info, &amp;multisample_state_create_info,</span><br><span class="line">                                          &amp;depth_and_stencil_state_create_info, &amp;blend_state_create_info,</span><br><span class="line">                                          &amp;dynamic_state_create_info, pipeline_layout, render_pass,</span><br><span class="line">                                          subpass, base_pipeline_handle, <span class="number">-1</span>, graphics_pipeline_create_info );</span><br><span class="line"><span class="keyword">if</span>( !CreateGraphicsPipelines( logical_device, &#123;</span><br><span class="line">    graphics_pipeline_create_info &#125;, pipeline_cache, graphics_pipeline ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="multiple-thread"><a href="#multiple-thread" class="headerlink" title="multiple thread"></a>multiple thread</h2><h3 id="Creating-multiple-graphics-pipelines-on-multiple-threads"><a href="#Creating-multiple-graphics-pipelines-on-multiple-threads" class="headerlink" title="Creating multiple graphics pipelines on multiple threads"></a>Creating multiple graphics pipelines on multiple threads</h3><p>创建graphic pipeline 可能会话很长时间.shader编译链接在pipeline创建时完成,指定给shader的states是否正常.所以有大量pipeline需要创建时最好使用多线程.</p>
<p>但当有大量pipeline创建时需要使用cachee去加速创建过程.本节会介绍在多并发管道(multiple concurrent pipeline)创建时使用cache并在之后合并cache.</p>
<p>本节使用VkDestroyer&lt;&gt;模板来自动销毁无用的资源</p>
<p>流程</p>
<blockquote>
<ul>
<li>cache文件std::string pipeline_cache_filename</li>
<li>cache从文件加载到std::vector<unsigned char> cache_data;</unsigned></li>
<li>std::vector<vkpipelinecache> pipeline_caches.为每个独立的thread创建pipeline cache object并存储句柄到pipeline_caches</vkpipelinecache></li>
<li>std::vector\<a href="std::thread\" target="_blank" rel="noopener">std::thread\</a> threads.  resize</li>
<li>创建变量std::vector\&lt;std::vector\&lt;VkGraphicsPipelineCreateInfo>>  graphics_pipelines_create_infos.为每个thread添加新的VkGraphicsPipelineCreateInfo graphics_pipelines_create_infos.并存储到线程创建的pipeline数等大的数组里.</li>
<li>创建变量std::vector\&lt;std::vector\&lt;VkPipeline>>  graphics_pipelines.按照每个thread的pipelines数量resize graphics_pipelines的子数组.</li>
<li>创建期望数量的threads,每个thread使用logical_device创建选定数量的pipelines,一个cache关联到该thread(pipeline_caches[<thread number>]),一个VkGraphicsPipelineCreateInfo数组关联到该thread(graphics_pipelines_create_infos[<thread number>]).</thread></thread></li>
<li>等待所有threads结束</li>
<li>创建一个VkPipelineCache target_cache</li>
<li>合并pipeline_caches数组到 target_cache.</li>
<li>遍历target_cache内容,存储到cache_data数组.</li>
<li>将cache_data存储到文件pipeline_cache_filename</li>
</ul>
<p>创建multiple graphics pipeline要求给很多不同pipelines提供很多参数.</p>
<p>为了速度更快,使用pipeline cache非常有效,首先需要从文件里读取预先存储的cache(如果有的话).然后为每个独立thread创建cache.每个cache需要用文件里加载的cache内容初始化.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; cache_data;</span><br><span class="line">&gt; GetBinaryFileContents( pipeline_cache_filename, cache_data );</span><br><span class="line">&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkDestroyer&lt;VkPipelineCache&gt;&gt; pipeline_caches(</span><br><span class="line">&gt;     graphics_pipelines_create_infos.size() );</span><br><span class="line">&gt; <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; graphics_pipelines_create_infos.size(); ++i ) &#123;</span><br><span class="line">&gt;     pipeline_caches[i] = VkDestroyer&lt; VkPipelineCache &gt;( logical_device );</span><br><span class="line">&gt;     <span class="keyword">if</span>( !CreatePipelineCacheObject( logical_device, cache_data,</span><br><span class="line">&gt;                                    *pipeline_caches[i] ) ) &#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>下一步是为每个thread创建的pipeline handles准备存储空间.同时开始所有thread使用对应的cache object创建多pipelines.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;threads( graphics_pipelines_create_infos.size() );</span><br><span class="line">&gt; <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; graphics_pipelines_create_infos.size(); ++i ) &#123;</span><br><span class="line">&gt;     graphics_pipelines[i].resize( graphics_pipelines_create_infos[i].size()</span><br><span class="line">&gt;                                 );</span><br><span class="line">&gt;     threads[i] = <span class="built_in">std</span>::thread::thread( CreateGraphicsPipelines,</span><br><span class="line">&gt;                                      logical_device, graphics_pipelines_create_infos[i], *pipeline_caches[i],</span><br><span class="line">&gt;                                      graphics_pipelines[i] );</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>等待所有thread完成.然后合并所有cache objects到一个.将新内容存储(replace)到对应文件.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; graphics_pipelines_create_infos.size(); ++i ) &#123;</span><br><span class="line">&gt;     threads[i].join();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; VkPipelineCache target_cache = *pipeline_caches.back();</span><br><span class="line">&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkPipelineCache&gt; source_caches( pipeline_caches.size() - <span class="number">1</span>);</span><br><span class="line">&gt; <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pipeline_caches.size() - <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">&gt;     source_caches[i] = *pipeline_caches[i];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">if</span>( !MergeMultiplePipelineCacheObjects( logical_device, target_cache,</span><br><span class="line">&gt;                                        source_caches ) ) &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">if</span>( !RetrieveDataFromPipelineCache( logical_device, target_cache,</span><br><span class="line">&gt;                                    cache_data ) ) &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">if</span>( !SaveBinaryFile( pipeline_cache_filename, cache_data ) ) &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h2><h3 id="Destroy-pipeline"><a href="#Destroy-pipeline" class="headerlink" title="Destroy pipeline"></a>Destroy pipeline</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != pipeline ) &#123;</span><br><span class="line">    vkDestroyPipeline( logical_device, pipeline, <span class="literal">nullptr</span> );</span><br><span class="line">    pipeline = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要确保commands已经完成(通过fences).</p>
<h3 id="Destroy-a-pipeline-cache"><a href="#Destroy-a-pipeline-cache" class="headerlink" title="Destroy a pipeline cache"></a>Destroy a pipeline cache</h3><p>当用来创建了pipeline,合并cache data,或遍历了内容后可以销毁cache.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != pipeline_cache ) &#123;</span><br><span class="line">    vkDestroyPipelineCache( logical_device, pipeline_cache, <span class="literal">nullptr</span> );</span><br><span class="line">    pipeline_cache = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Destroying-a-pipeline-layout"><a href="#Destroying-a-pipeline-layout" class="headerlink" title="Destroying a pipeline layout"></a>Destroying a pipeline layout</h3><p>当不需要pipeline layout时,也就是不想用它来创建更多pipeline、绑定descriptor sets或更新push constants(给定layout使用的)、使用这个pipeline layout的所有操作已经完成,我们能销毁它.</p>
<p>Pipeline layouts只在三种情况游泳–创建pipelines,绑定descriptor sets,update push constants.第一种可以用完就销毁,后两种在硬件停止运行相关cbs后销毁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != pipeline_layout ) &#123;</span><br><span class="line">    vkDestroyPipelineLayout( logical_device, pipeline_layout, <span class="literal">nullptr</span> );</span><br><span class="line">    pipeline_layout = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Destroying-a-shadr-module"><a href="#Destroying-a-shadr-module" class="headerlink" title="Destroying a shadr module"></a>Destroying a shadr module</h3><p>Shader modules只用于创建pipeline objects.完成后能立即销毁.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( VK_NULL_HANDLE != shader_module ) &#123;</span><br><span class="line">    vkDestroyShaderModule( logical_device, shader_module, <span class="literal">nullptr</span> );</span><br><span class="line">    shader_module = VK_NULL_HANDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://noleafnolife.com/2019/03/16/postprocess/UE4tonemaptounity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nolife">
      <meta itemprop="description" content="一个游戏程序员的blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stoner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/16/postprocess/UE4tonemaptounity/" class="post-title-link" itemprop="url">UE4的Film ACES移植到unity中</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-16 19:13:00 / Modified: 19:13:59" itemprop="dateCreated datePublished" datetime="2019-03-16T19:13:00+08:00">2019-03-16</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/render/" itemprop="url" rel="index"><span itemprop="name">render</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/render/Postprocess/" itemprop="url" rel="index"><span itemprop="name">Postprocess</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>本文简单介绍如何讲UE4后处理移植到unity中</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/16/postprocess/UE4tonemaptounity/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">nolife</p>
              <div class="site-description motion-element" itemprop="description">一个游戏程序员的blog</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nolife</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  

  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
